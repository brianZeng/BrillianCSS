/* parser generated by jison 0.4.15 */
/*
 Returns a Parser object of the following structure:

 Parser: {
 yy: {}
 }

 Parser.prototype: {
 yy: {},
 trace: function(),
 symbols_: {associative list: name ==> number},
 terminals_: {associative list: number ==> name},
 productions_: [...],
 performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
 table: [...],
 defaultActions: {...},
 parseError: function(str, hash),
 parse: function(input),

 lexer: {
 EOF: 1,
 parseError: function(str, hash),
 setInput: function(input),
 input: function(),
 unput: function(str),
 more: function(),
 less: function(n),
 pastInput: function(),
 upcomingInput: function(),
 showPosition: function(),
 test_match: function(regex_match_array, rule_index),
 next: function(),
 lex: function(),
 begin: function(condition),
 popState: function(),
 _currentRules: function(),
 topState: function(),
 pushState: function(condition),

 options: {
 ranges: boolean           (optional: true ==> token location info will include a .range[] member)
 flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
 backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
 },

 performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
 rules: [...],
 conditions: {associative list: name ==> set},
 }
 }


 token location info (@$, _$, etc.): {
 first_line: n,
 last_line: n,
 first_column: n,
 last_column: n,
 range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
 }


 the parseError function receives a 'hash' object with these members for lexer and parser errors: {
 text:        (matched text)
 token:       (the produced terminal token, if any)
 line:        (yylineno)
 }
 while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
 loc:         (yylloc)
 expected:    (string describing the set of expected tokens)
 recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
 }
 */
var parser = (function () {
  var o = function (k, v, o, l) {
    for (o = o || {}, l = k.length; l--; o[k[l]] = v);
    return o
  }, $V0 = [1, 8], $V1 = [1, 9], $V2 = [1, 7], $V3 = [1, 5, 31, 40, 44], $V4 = [1, 12], $V5 = [1, 5, 31, 32, 40, 44], $V6 = [1, 17], $V7 = [1, 15], $V8 = [10, 16, 35], $V9 = [1, 5, 26, 28, 30, 31, 32, 36, 37, 40, 44], $Va = [1, 30], $Vb = [1, 24], $Vc = [1, 27], $Vd = [1, 28], $Ve = [1, 43], $Vf = [1, 44], $Vg = [1, 45], $Vh = [1, 46], $Vi = [1, 47], $Vj = [1, 39], $Vk = [1, 40], $Vl = [1, 42], $Vm = [26, 28, 30, 31, 36, 37], $Vn = [1, 50], $Vo = [26, 28, 30, 31, 32, 36, 37], $Vp = [26, 28, 30, 31, 32, 35, 36, 37], $Vq = [11, 16], $Vr = [1, 4, 5, 7, 10, 11, 13, 16, 17, 18, 19, 26, 28, 30, 31, 32, 36, 37, 40, 44], $Vs = [1, 60], $Vt = [1, 61], $Vu = [1, 62], $Vv = [1, 63], $Vw = [1, 4, 5, 6, 7, 8, 9, 10, 11, 13, 16, 17, 18, 19, 26, 28, 30, 31, 32, 36, 37, 40, 44], $Vx = [1, 4, 5, 6, 7, 10, 11, 13, 16, 17, 18, 19, 26, 28, 30, 31, 32, 36, 37, 40, 44];
  var parser = {trace: function trace() {
  },
    yy: {},
    symbols_: {"error": 2, "exp": 3, "NUMBER": 4, "VAR": 5, "+": 6, "-": 7, "*": 8, "/": 9, "(": 10, ")": 11, "inlineFunc": 12, "FUNCNAME": 13, "funcParam": 14, "property": 15, ",": 16, "STRING": 17, "URL": 18, "LITERAL": 19, "list": 20, "assignPair": 21, ":": 22, "assignList": 23, "defParamList": 24, "includeCall": 25, "INCLUDE": 26, "scopeBodyPart": 27, "IDENT": 28, "nestedStyle": 29, "EXTENDS": 30, "SELECTOR": 31, ";": 32, "scopeBody": 33, "scope": 34, "{": 35, "}": 36, "&": 37, "style": 38, "mixScope": 39, "MIXIN": 40, "selectors": 41, "sheetPart": 42, "sheet": 43, "EOF": 44, "$accept": 0, "$end": 1},
    terminals_: {2: "error", 4: "NUMBER", 5: "VAR", 6: "+", 7: "-", 8: "*", 9: "/", 10: "(", 11: ")", 13: "FUNCNAME", 16: ",", 17: "STRING", 18: "URL", 19: "LITERAL", 22: ":", 26: "INCLUDE", 28: "IDENT", 30: "EXTENDS", 31: "SELECTOR", 32: ";", 35: "{", 36: "}", 37: "&", 40: "MIXIN", 44: "EOF"},
    productions_: [0, [3, 1], [3, 1], [3, 3], [3, 3], [3, 3], [3, 3], [3, 2], [3, 3], [12, 3], [12, 4], [14, 1], [14, 3], [15, 1], [15, 1], [15, 1], [15, 1], [15, 1], [20, 1], [20, 2], [21, 3], [23, 1], [23, 3], [24, 2], [24, 3], [25, 3], [25, 2], [27, 3], [27, 1], [27, 1], [27, 2], [27, 2], [33, 1], [33, 2], [34, 3], [34, 4], [34, 3], [34, 2], [29, 2], [29, 1], [39, 3], [41, 1], [41, 3], [38, 2], [42, 1], [42, 1], [42, 1], [42, 2], [43, 1], [43, 2], [43, 2]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
      /* this == yyval */

      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          this.$ = new Exp(new Length($$[$0]));
          break;
        case 2:
          this.$ = new Exp($$[$0]);
          break;
        case 3:
        case 4:
        case 5:
        case 6:
          this.$ = new Exp($$[$0 - 2], $$[$0 - 1], $$[$0]).reduce();
          break;
        case 7:
          this.$ = new Exp(new Length('0'), '-', $$[$0]).reduce();
          break;
        case 8:
          this.$ = $$[$0 - 1].reduce();
          break;
        case 9:
          this.$ = new InlineFunc($$[$0 - 2]);
          break;
        case 10:
          this.$ = new InlineFunc($$[$0 - 3], $$[$0 - 1].reduce());
          break;
        case 11:
          this.$ = new List($$[$0].resolve());
          break;
        case 12:
          $$[$0 - 2].push($$[$0].resolve());
          break;
        case 13:
        case 16:
          this.$ = $$[$0].reduce();
          break;
        case 18:
        case 41:
          this.$ = new List($$[$0]);
          break;
        case 19:
          $$[$0 - 1].push($$[$0]);
          break;
        case 20:
          this.$ = {name: $$[$0 - 2], value: $$[$0].reduce()};
          break;
        case 21:
          this.$ = {};
          this.$[$$[$0].name] = $$[$0].value
          break;
        case 22:
          $$[$0 - 2][$$[$0].name] = $$[$0].value
          break;
        case 23:
          this.$ = {};
          break;
        case 24:
        case 34:
          this.$ = $$[$0 - 1];
          break;
        case 25:
          this.$ = {name: $$[$0 - 1], value: $$[$0]};
          break;
        case 26:
          this.$ = {name: $$[$0], value: {}};
          break;
        case 27:
          this.$ = {name: $$[$0 - 2], value: $$[$0].resolve(), type: 'rule'};
          console.log($$[$0]);
          break;
        case 28:
          this.$ = {type: 'style', value: $$[$0]};
          break;
        case 29:
          $$[$0].type = 'include';
          break;
        case 30:
          this.$ = {type: 'ext', name: $$[$0]};
          break;
        case 32:
          this.$ = new Scope().add($$[$0])
          break;
        case 33:
          this.$ = $$[$0 - 1].add($$[$0]);
          break;
        case 35:
          this.$ = $$[$0 - 1].addDefValues($$[$0 - 3]);
          break;
        case 36:
          this.$ = new Scope().addDefValues($$[$0 - 2]);
          break;
        case 38:
        case 43:
          this.$ = new Style($$[$0 - 1], $$[$0]);
          break;
        case 40:
          this.$ = $$[$0];
          $$[$0].name = $$[$0 - 1];
          break;
        case 42:
          $$[$0 - 2].add($$[$0]);
          break;
        case 44:
          this.$ = {type: 'style', value: $$[$0]}
          break;
        case 45:
          this.$ = {type: 'mix', value: $$[$0]};
          break;
        case 46:
          $$[$0].type = 'def';
          break;
        case 48:
          this.$ = new Sheet().add($$[$0])
          break;
        case 49:
          $$[$0 - 1].add($$[$0]);
          break;
        case 50:
          return $$[$0 - 1];
          break;
      }
    },
    table: [
      {5: $V0, 21: 5, 31: $V1, 38: 3, 39: 4, 40: $V2, 41: 6, 42: 2, 43: 1},
      {1: [3], 5: $V0, 21: 5, 31: $V1, 38: 3, 39: 4, 40: $V2, 41: 6, 42: 10, 44: [1, 11]},
      o($V3, [2, 48], {32: $V4}),
      o($V5, [2, 44]),
      o($V5, [2, 45]),
      o($V5, [2, 46]),
      {10: $V6, 16: [1, 14], 24: 16, 34: 13, 35: $V7},
      {5: [1, 18]},
      {22: [1, 19]},
      o($V8, [2, 41]),
      o($V3, [2, 49], {32: $V4}),
      o($V3, [2, 50]),
      o($V5, [2, 47]),
      o($V9, [2, 43]),
      {31: [1, 20]},
      {25: 26, 26: $Va, 27: 23, 28: $Vb, 29: 25, 30: $Vc, 31: $V1, 33: 21, 36: [1, 22], 37: $Vd, 38: 29, 41: 6},
      {35: [1, 31]},
      {5: $V0, 11: [1, 32], 21: 34, 23: 33},
      {10: $V6, 24: 16, 34: 35, 35: $V7},
      {3: 38, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh, 12: 41, 13: $Vi, 15: 37, 17: $Vj, 18: $Vk, 19: $Vl, 20: 36},
      o($V8, [2, 42]),
      {25: 26, 26: $Va, 27: 49, 28: $Vb, 29: 25, 30: $Vc, 31: $V1, 36: [1, 48], 37: $Vd, 38: 29, 41: 6},
      o($V9, [2, 37]),
      o($Vm, [2, 32], {32: $Vn}),
      {22: [1, 51]},
      o($Vo, [2, 28]),
      o($Vo, [2, 29]),
      {31: [1, 52]},
      {10: $V6, 24: 16, 34: 53, 35: $V7},
      o($Vo, [2, 39]),
      {5: [1, 54]},
      {25: 26, 26: $Va, 27: 23, 28: $Vb, 29: 25, 30: $Vc, 31: $V1, 33: 55, 36: [1, 56], 37: $Vd, 38: 29, 41: 6},
      o($Vp, [2, 23]),
      {11: [1, 57], 16: [1, 58]},
      o($Vq, [2, 21]),
      o($V5, [2, 40]),
      o([1, 11, 16, 31, 32, 40, 44], [2, 20], {3: 38, 12: 41, 15: 59, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh, 13: $Vi, 17: $Vj, 18: $Vk, 19: $Vl}),
      o($Vr, [2, 18]),
      o([1, 4, 5, 10, 11, 13, 16, 17, 18, 19, 26, 28, 30, 31, 32, 36, 37, 40, 44], [2, 13], {6: $Vs, 7: $Vt, 8: $Vu, 9: $Vv}),
      o($Vr, [2, 14]),
      o($Vr, [2, 15]),
      o($Vr, [2, 16]),
      o($Vr, [2, 17]),
      o($Vw, [2, 1]),
      o($Vw, [2, 2]),
      {3: 64, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh},
      {3: 65, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh},
      {10: [1, 66]},
      o($V9, [2, 34]),
      o($Vm, [2, 33], {32: $Vn}),
      o($Vo, [2, 31]),
      {3: 38, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh, 12: 41, 13: $Vi, 15: 37, 17: $Vj, 18: $Vk, 19: $Vl, 20: 67},
      o($Vo, [2, 30]),
      o($Vo, [2, 38]),
      o($Vo, [2, 26], {24: 68, 10: $V6}),
      {25: 26, 26: $Va, 27: 49, 28: $Vb, 29: 25, 30: $Vc, 31: $V1, 36: [1, 69], 37: $Vd, 38: 29, 41: 6},
      o($V9, [2, 36]),
      o($Vp, [2, 24]),
      {5: $V0, 21: 70},
      o($Vr, [2, 19]),
      {3: 71, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh},
      {3: 72, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh},
      {3: 73, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh},
      {3: 74, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh},
      o($Vw, [2, 7]),
      {6: $Vs, 7: $Vt, 8: $Vu, 9: $Vv, 11: [1, 75]},
      {3: 38, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh, 11: [1, 76], 12: 41, 13: $Vi, 14: 77, 15: 78, 17: $Vj, 18: $Vk, 19: $Vl},
      o($Vo, [2, 27], {3: 38, 12: 41, 15: 59, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh, 13: $Vi, 17: $Vj, 18: $Vk, 19: $Vl}),
      o($Vo, [2, 25]),
      o($V9, [2, 35]),
      o($Vq, [2, 22]),
      o($Vx, [2, 3], {8: $Vu, 9: $Vv}),
      o($Vx, [2, 4], {8: $Vu, 9: $Vv}),
      o($Vw, [2, 5]),
      o($Vw, [2, 6]),
      o($Vw, [2, 8]),
      o($Vr, [2, 9]),
      {11: [1, 79], 16: [1, 80]},
      o($Vq, [2, 11]),
      o($Vr, [2, 10]),
      {3: 38, 4: $Ve, 5: $Vf, 7: $Vg, 10: $Vh, 12: 41, 13: $Vi, 15: 81, 17: $Vj, 18: $Vk, 19: $Vl},
      o($Vq, [2, 12])
    ],
    defaultActions: {},
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        throw new Error(str);
      }
    },
    parse: function parse(input) {
      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }

      _token_stack:
        function lex() {
          var token;
          token = lexer.lex() || EOF;
          if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
          }
          return token;
        }
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
          var errStr = '';
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push('\'' + this.terminals_[p] + '\'');
            }
          }
          if (lexer.showPosition) {
            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
          } else {
            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
          }
          this.parseError(errStr, {
            text: lexer.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer.yylineno,
            loc: yyloc,
            expected: expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer.yyleng;
              yytext = lexer.yytext;
              yylineno = lexer.yylineno;
              yyloc = lexer.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }};

  /**
   * Created by 柏然 on 2014/10/21.
   */
  /**
   * Created by 柏然 on 2014/10/10.
   */
  function Exp(left, optor, right) {
    if (!(this instanceof Exp))return new Exp(left, right, optor);
    this.left = left;
    if (right)this.right = right;
    if (optor) this.optor = optor;
  }

  function Length(str) {
    if (!(this instanceof Length)) return new Length(str);
    var m;
    if (!isNaN(str)) {
      this.num = parseFloat(str);
      this.unit = '';
    }
    if (typeof str == "string") {
      m = str.match(/^\-?((\d+(\.\d+)?)|(\.\d+))/);
      if (m) {
        this.num = parseFloat(m[0]);
        this.unit = str.substr(m[0].length);
      }
      else return str;
    }
  }

  function Scope() {
    this.parent = null;
    this.staticRules = {};
    this.dynamicRules = {};
    this.defValues = {};
    this.includes = {};
    this.nested = [];
    this.exts = [];
  }

  function List() {
    if (!(this instanceof List))return new List(arguments);
    for (var i = 0, len = arguments.length; i < len; i++)
      this.add(arguments[i]);
  }

  function InlineFunc(name, paramList) {
    this.name = name;
    this.param = paramList || new List();
  }

  function Style(selector, scope) {
    Scope.apply(this);
    this.selector = selector;
    this.addScope(scope);
  }

  function Sheet() {
    this.defValues = {};
    this.styles = new List();
    this.mixins = {};
  }

  Exp.isVar = function (str) {
    return (typeof  str === "string" && str[0] == '$');
  };
  Exp.getType = function (side) {
    if (!side)return Exp.TYPE.NONE;
    if (Exp.isVar(side))return Exp.TYPE.VAR;
    else if (side instanceof Length)return Exp.TYPE.LENGTH;
    else if (side instanceof Exp)return Exp.TYPE.EXP;
    else if (side instanceof InlineFunc)return Exp.TYPE.FUNC;
    else if (typeof side == "string") return Exp.TYPE.KEYWORD;
    else throw  Error('unknown type');
  };
  Exp.TYPE = {
    NONE: 'no',
    EXP: 'exp',
    VAR: 'var',
    LENGTH: 'len',
    FUNC: 'fun',
    KEYWORD: 'lit'
  };
  List.arrayAdd = function arrayAdd(array, item) {
    if (item instanceof Array)
      for (var i = 0, len = item.length; i < len; i++) arguments.callee(array, item[i]);
    else {
      if (array.indexOf(item) > -1)return false;
      else array.push(item);
    }
    return true;
  };
  List.uniquePush = function (a) {
    for (var i = 1, change = false, arr = arguments[1], add = List.arrayAdd; arr; arr = arguments[++i])
      for (var j = 0, len = arr.length; j < len; j++)
        if (add(a, arr[j]))change = true;

    return change;
  };
  Exp.prototype = {
    opt: function (opt, exp) {
      var left = this.left;
      if (left instanceof Length && exp instanceof Length)
        this.left = left.opt(opt, exp);
      else {
        this.optor = opt;
        this.right = exp;
      }
      return this;
    },
    get isVar() {
      return this.right == undefined && Exp.isVar(this.left);
    },
    get value() {
      if (this.hasVars) return undefined;
      switch (this.type) {
        case Exp.TYPE.KEYWORD:
        case Exp.TYPE.LENGTH:
          return this.left;
        default:
          return this.left.opt(this.optor, this.right);
      }
    },
    reduce: function () {
      var left = this.left, right = this.right;
      if (left instanceof Exp)left = left.reduce();
      if (right instanceof Exp)right = right.reduce();

      if (left.isVar)this.left = left.left;
      else this.left = left;

      if (right)
        if (right instanceof Length && left instanceof Length) {
          this.left = left.opt(this.optor, right);
          delete this.right;
          delete this.optor;
          return this.left;
        }
        else if (right.isVar) this.right = right.left;
        else this.right = right;
      else if (left instanceof Length) return (this.left = left);
      else if (left.isVar)this.left = left.left;
      else this.left = left;

      return this.clearVarNames();
    },
    canResolve: function ($vars) {
      return this.getVarNames().every(function (name) {
        return $vars[name] !== undefined;
      });
    },
    clearVarNames: function () {
      delete this.variables;
      var left = this.left, right = this.right;
      if (left.clearVarNames)left.clearVarNames();
      if (right && right.clearVarNames)right.clearVarNames();
      return this;
    },
    get hasVars() {
      var a = this.getVarNames();
      return a.length > 0;
    },
    get type() {
      if (Exp.getType(this.right) == Exp.TYPE.NONE)
        return Exp.getType(this.left);
      return Exp.TYPE.EXP;
    },
    resolve: (function () {
      function resolveExp(exp, $vars) {
        var left = exp.left, right = exp.right, tem, ltype = Exp.getType(left), rtype = Exp.getType(right), ret = exp, clearVars = true, clearRight;
        switch (ltype) {
          case Exp.TYPE.VAR:
            tem = tem = $vars[left];
            if (tem !== undefined) {
              clearVars = true;
              ltype = Exp.getType(left = exp.left = tem);
            }
            break;
          case Exp.TYPE.LENGTH:
          case Exp.TYPE.KEYWORD:
            ret = left;
            break;
          case Exp.TYPE.EXP:
          case Exp.TYPE.FUNC:
            exp.left = left.resolve($vars);
            return exp.clearVarNames();
          case Exp.TYPE.NONE:
            throw Error('invalid type');
        }
        switch (rtype) {
          case Exp.TYPE.NONE:
            clearRight = true;
            break;
          case Exp.TYPE.LENGTH:
            if (clearRight = (ltype == Exp.TYPE.LENGTH))ret = exp.left = left.opt(exp.optor, right);
            break;
          case Exp.TYPE.KEYWORD:
            throw Error('invalid type');
          case Exp.TYPE.VAR:
            tem = $vars[right];
            if (tem !== undefined)
              clearVars = !!(exp.right = tem);
            break;
          case Exp.TYPE.EXP:
            exp.right = right.resolve($vars);
            return exp.clearVarNames();
        }
        if (clearRight) {
          delete exp.optor;
          delete exp.right;
        }
        if (clearVars)exp.clearVarNames();
        return ret;
      }

      return function ($vars) {
        $vars = $vars || {};
        var v = this.clone();
        while (v.hasVars && v.canResolve($vars))
          resolveExp(v, $vars);
        return v.hasVars ? v : v.value;
      }
    })(),
    getVarNames: function (array) {
      var vars;
      if (!(vars = this.variables)) {
        var left = this.left, right = this.right;
        vars = this.variables = [];
        if (Exp.isVar(left)) List.arrayAdd(vars, left);
        else if (left instanceof Exp) left.getVarNames(vars);
        if (Exp.isVar(right))List.arrayAdd(vars, right);
        else if (right instanceof Exp) right.getVarNames(vars);
      }
      array = array || [];
      vars.forEach(function (key) {
        List.arrayAdd(array, key)
      });
      return array;
    },
    clone: function () {
      var left = this.left, r = new Exp(left.clone ? left.clone(true) : left), right;
      if ((right = this.right) !== undefined) {
        r.right = right.clone ? right.clone(true) : right;
        r.optor = this.optor;
      }
      return r;
    },
    toString: function () {
      var left = this.left, right = this.right;
      if (typeof left !== "string") left = left.toString();
      if (right) {
        if (typeof right !== "string") right = right.toString();
        return left + this.optor + right;
      }
      return left;
    }
  };
  Length.parse = function (str) {
    if (str instanceof Length) return str.clone();
    var l = new Length(str);
    return isNaN(l.num) ? undefined : l;
  };
  Length.prototype = {
    clone: function () {
      return new Length(this.num + this.unit);
    },
    opt: function (opt, exp) {
      var num, unit = this.unit, otherUnit = exp.unit;
      if (!exp) return this.clone();
      if (otherUnit && unit !== otherUnit)
        num = exp.convert(otherUnit, unit);
      else num = exp.num;
      unit = unit || otherUnit;
      switch (opt) {
        case '+':
          return new Length(this.num + num + unit);
        case '-':
          return new Length(this.num - num + unit);
        case '*':
          return new Length(this.num * num + unit);
        case '/':
          return new Length(this.num / num + unit);
        default :
          throw  'unkonwn optor:' + opt;
      }
    },
    convert: function (OtherUnit, thisUnit) {
      return this.num;
    },
    toString: function () {
      return isNaN(this.num) ? 'NaN' : (this.num + this.unit);
    },
    reduce: function () {
      return this;
    },
    resolve: function () {
      return this.toString();
    },
    get value() {
      return this.toString();
    }
  };
  List.fromObject = function (combiner, objArray) {
    if (!(objArray instanceof Array)) objArray = [objArray];
    for (var i = 0, list = new List, obj = objArray[0]; obj; obj = objArray[++i])
      Object.getOwnPropertyNames(obj).forEach(function (key) {
        list.push(key + combiner, obj[key]);
      });
    return list;
  };
  List.prototype = (function (proto) {
    proto.add = function (item) {
      if (this.indexOf(item) > -1)return false;
      this.push(item);
      return true;
    };
    proto.canResolve = function ($vars) {
      $vars = $vars || {};
      return this.every(function (obj) {
        return (obj.canResolve) ? obj.canResolve($vars) : true;
      });
    };
    proto.clone = function () {
      return arrayReduce(this, function (list, o) {
        list.push(o.clone ? o.clone(true) : o);
        return list;
      }, new List());
    };
    proto.copy = function (array) {
      if (Array.isArray(array)) {
        this.splice(0, this.length);
        Array.prototype.push.apply(this, array);
      }
      else {
        this.splice(0, this.length, array);
      }
      return this;
    };
    proto.resolve = function ($vars) {
      var v = arrayReduce(this, function (list, v) {
        var last = list[list.length - 1];
        v = v.resolve ? v.resolve($vars) : v;
        if (typeof v == "string" && typeof last == "string")
          list[list.length - 1] = last + ' ' + v;
        else list.push(v);
        return list;
      }, new List());
      return v.canResolve($vars) ? v.value : v.length == 1 ? v[0] : v;
    };
    proto.getVarNames = function (array) {
      array = array || [];
      this.forEach(function (o) {
        if (o.hasVars)o.getVarNames(array)
      });
      return array;
    };
    Object.defineProperty(proto, 'value', {
      get: function () {
        for (var i = 0, r = [], v, item = this[0]; item; item = this[++i]) {
          v = item.resolve ? item.resolve() : item;
          if (v == undefined) return undefined;
          r.push(v);
        }
        return r.length ? r.join(' ').replace(/[\s\r\n\t\f]+/g, ' ') : '';
      }
    });
    Object.defineProperty(proto, 'resolved', {
      get: function () {
        return this.every(function (v) {
          return v instanceof Length || typeof v == "string";
        })
      }
    });
    proto.toString = function () {
      return this.join(' ').replace(/[\r\n\s\t\f]+/gi, ' ');
    };
    var arrayReduce = function (array, callback, initialValue) {
      return Array.prototype.reduce.apply(array, [callback, initialValue]);
    };
    proto.reduce = function (callback, initialValue) {
      if (arguments.length == 0)
        return this.copy(this.map(function (obj) {
          return obj.reduce ? obj.reduce() : obj
        }));
      else
        return arrayReduce(this, callback, initialValue);
    };
    return proto;
  })(Object.create([]));
  InlineFunc.prototype = {
    resolve: function ($vars, info) {
      var v = this.param.resolve($vars, info);
      return typeof v == "string" ? this.name + '(' + v.replace(/\s+/gi, ',') + ')' : this;
    },
    get value() {
      var v = this.paramValue;
      return v == undefined ? undefined : this.name + v;
    },
    reduce: function () {
      var p = this.param;
      this.param = p.reduce ? this.param.reduce() : p;
      return this;
    },
    clone: function () {
      var p = this.param;
      return new InlineFunc(this.name, p.clone ? p.clone() : p);
    },
    canResolve: function ($vars) {
      var p = this.param;
      return typeof p == "string" ? true : p.canResolve($vars);
    },
    toString: function () {
      return this.name + this.paramString;
    },
    get paramString() {
      var v = this.param.toString();
      return '(' + v.replace(/\s+/gi, ',') + ')';
    },
    get paramValue() {
      var v = this.param.value;
      return v == undefined ? undefined : '(' + v.replace(/\s+/gi, ',') + ')';
    }
  };
  Scope.prototype = {
    mixParam: (function () {
      function cloneIfNotHas(a, from) {
        var v;
        if (from)
          Object.getOwnPropertyNames(from).forEach(function (key) {
            if (!a.hasOwnProperty(key)) {
              v = from[key];
              a[key] = v.clone ? v.clone(true) : v;
            }
          });
        return a;
      }

      function inheritDefValues(assign, scope) {
        var o = cloneIfNotHas({}, assign), p = scope;
        while (p) {
          o = cloneIfNotHas(o, p.defValues);
          p = p.parent;
        }
        return o;
      }

      return function (assign) {
        return inheritDefValues(assign, this);
      }
    })(),
    toString: function ($vars) {
      return this.resolve($vars).join('\n');
    },
    get value() {
      var s = this.toString();
      return s.match(/^\{[\s\r\n\t\f;]*\}$/, s) ? undefined : s;
    },
    get paramString() {
      var r = [];
      objForEach(this.defValues, function (key, value) {
        r.push(key + ':' + value)
      });
      return r.length ? '(' + r.join(',') + ')' : '';
    },
    getBodyString: function ($vars, unresolvedInclude, context) {

    },
    getFullString: function ($vars) {
      return this.paramString + this.getBodyString($vars, true);
    },
    add: function (obj) {
      switch (obj.type.toLowerCase()) {
        case 'rule' :
          return this.addRule(obj.name, obj.value);
        case 'def':
          return this.addDefValues(obj.name, obj.value);
        case 'style':
          return this.addStyle(obj.value);
        case 'include':
          return this.addInclude(obj.name, obj.value);
        case 'ext':
          return this.addExt(obj.name);
        case 'mix':
          return this.addMix(obj.value);
      }
      return this;
    },
    addExt: function (selector) {
      List.arrayAdd(this.exts, Style.trimSelector(selector));
      return this;
    },
    addRule: function (key, value) {
      if (typeof value !== "string") this.dynamicRules[key] = value;
      else this.staticRules[key] = value;
      return this;
    },
    addDefValues: function (objOrkey, value) {
      var v;
      if (typeof objOrkey == "string") {
        if (value instanceof List && value.length == 1)value = value[0];
        else if (value.resolve) v = value.resolve();
        this.defValues[objOrkey] = Length.parse(v) || value;
      }
      else objForEach(objOrkey, function (key, v) {
        this.addDefValues(key, v);
      }, this);
      return this;
    },
    addStyle: function (style) {
      var s, ts;
      if (style instanceof Scope) {
        this.nested.push(style);
        style.parent = this;
      }
      return this;
    },
    addInclude: function (varName, rules) {
      this.includes[varName] = rules;
      return this;
    },
    canResolve: function ($vars) {
      $vars = this.mixParam($vars || {});
      return Object.getOwnPropertyNames(this.dynamicRules).every(function (key) {
        return this[key].canResolve($vars);
      }, this.dynamicRules);
    },
    clone: (function () {
      function onPair(key, value) {
        this[key] = value.clone ? value.clone(true) : value;
      }

      return function () {
        var r = new Scope(), parent = this.parent;
        objForEach(this.staticRules, onPair, r.staticRules);
        objForEach(this.dynamicRules, onPair, r.dynamicRules);
        objForEach(this.defValues, onPair, r.defValues);
        objForEach(this.includes, onPair, r.includes);
        if (parent) r.parent = parent;
        r.nested = this.nested.map(function (scope) {
          return scope.clone();
        });
        r.exts = this.exts.slice();
        return r;
      }
    })(),
    resolveSelf: function ($vars, info) {
      var $known = this.assign($vars, info), rules = mix(this.staticRules), knownNames = Object.getOwnPropertyNames($known);
      objForEach(this.dynamicRules, function (key, value) {
        if (value.canResolve($known))
          rules[key] = value.clone().resolve($known);
        else if (info)
          info[key] = this.recordUnresolvedInfo(knownNames, value);
      }, this);
      return rules;
    },
    resolveNested: function ($vars, arg) {
      return this.nested.reduce(function (r, scope) {
        r.push.apply(r, scope.resolve($vars, arg));
        return r;
      }, []);
    },
    recordUnresolvedInfo: function ($known, unresolved) {
      var knownNames = $known instanceof Array ? $known : Object.getOwnPropertyNames($known), r = [];
      unresolved.getVarNames().forEach(function (v) {
        if (knownNames.indexOf(v) == -1) List.arrayAdd(r, v);
      });
      return 'exp:|' + unresolved + '| unable to find var:' + r.join(' ');
    },
    assign: function (assigns, info, unresolved) {
      var result = {}, unres = this.mixParam(assigns), con;
      do {
        con = false;
        Object.getOwnPropertyNames(unres).forEach(function (key) {
          var value = unres[key], len;
          while (value.canResolve && value.canResolve(result))
            value = value.resolve(result);
          if ((value instanceof Length) || (value instanceof List && value.resolved))
            len = value;
          else if (typeof value == "string") len = Length.parse(value) || value;
          if (len) {
            result[key] = len;
            con = true;
            delete unres[key];
          }
        });
        if (!con)
          con = Object.getOwnPropertyNames(unres).some(function (key) {
            return unres[key].canResolve(result);
          });
      } while (con);
      if (info) {
        var known = Object.getOwnPropertyNames(result);
        objForEach(unres, function (key, value) {
          info[key] = this.recordUnresolvedInfo(known, value);
        }, this);
      }
      if (unresolved && typeof unresolved == "object")
        for (var i in unres) unresolved[i] = unres[i];
      return result;
    },
    reduce: function () {
      var staticRules = this.staticRules, v;
      objForEach(this.dynamicRules, function (key, value) {
        v = value.value;
        if (v !== undefined) {
          delete this[key];
          staticRules[key] = v;
        }
      });
      return this;
    },
    remove: function (key) {
      if (Exp.isVar(key)) return delete this.defValues[key];
      if (this.staticRules.hasOwnProperty(key))return delete this.staticRules[key];
      if (this.dynamicRules.hasOwnProperty(key))return delete this.dynamicRules[key];
    },
    resolve: (function () {
      function assignIncludeParam($param, $known) {
        var r = {};
        objForEach($param, function (key, value) {
          if (value.resolve && value.canResolve($known))
            r[key] = value.resolve($known);
          else if (typeof value == "string")
            r[key] = value;
        });
        for (var i in $known) if (!r.hasOwnProperty(i))r[i] = $known[i];
        return r;
      }

      function resolveInclude(mixin, $param, selfRules, arg) {
        var $known, selfRule, r = [];
        $known = mixin.assign($param, arg.info);
        selfRule = mixin.resolveSelf($known, arg.info);
        objForEach(selfRule, function (key, value) {
          selfRules[key] = value
        });
        r.push.apply(r, resolveIncludeNested(mixin, $known, arg));
        r.push.apply(r, resolveIncludes(mixin.includes, $known, selfRules, arg));
        return r;
      }

      function resolveIncludeNested(mixin, $param, arg) {
        mixin.selector = arg.selector;
        var r = mixin.resolveNested($param, arg);
        mixin.selector = '';
        return r;
      }

      function resolveIncludes(includesObj, $known, selfResults, arg) {
        var r = [];
        objForEach(includesObj, function (key, paramList) {
          var mixin = arg.getMixScope(key);
          if (mixin)
            r.push.apply(r, resolveInclude(mixin, assignIncludeParam(paramList, $known), selfResults, arg));
        });
        return r;
      }

      function getObjString(obj, separator) {
        for (var r = Object.getOwnPropertyNames(obj), i = 0, key = r[0]; key; key = r[++i])
          r[i] = key + ':' + obj[key] + ';';
        return '{\n' + r.join(separator || '\r\n') + (r.length ? '\n}' : '}');
      }

      return function ($vars, arg) {
        arg = arg || {info: {}};
        var $unkonwn = {}, $known = this.assign($vars, arg.info, $unkonwn), selfResult, results = [];
        selfResult = this.resolveSelf($known, arg.info);
        if (arg.getMixScope) {
          arg.selector = this.selector || '';
          results = resolveIncludes(this.includes, $known, selfResult, arg);
        }
        results.unshift.apply(results, this.resolveNested($vars, arg));
        results.unshift({body: getObjString(selfResult, arg.separator), selector: this.selector});
        if (arg.setExtends)arg.setExtends(this);
        return results;
      }
    })()
  };
  Style.trimSelector = function (selector) {
    return selector.replace(/[\r\n\t\f\s]+/gi, ' ').trim();
  };
  Style.prototype = (function (scopeProto) {
    var cloneFunc = scopeProto.clone, proto;
    proto = Object.create(scopeProto);
    proto.getFullString = function ($vars, unresolved) {
      return this.selector + proto.getFullString.apply(this, [$vars, unresolved]);
    };
    proto.toString = function ($vars) {
      return this.selector + this.getBodyString($vars);
    };
    Object.defineProperty(proto, 'selector', {
      get: function () {
        var sec = this._selector, p, ps, r, s;
        if (sec)return this._selector;
        s = this._selectorList;
        if (p = this.parent) {
          ps = p.selector.split(',');
          r = s.reduce(function (array, childSelector) {
            var concat = /^&/.test(childSelector) ? childSelector.substr(1).trim() : (' ' + childSelector);
            array.push.apply(array, ps.map(function (pSelector) {
              return pSelector + concat;
            }));
            return array;
          }, []);
        }
        else r = s;
        return this._selector = r.join(',');
      },
      set: function (list) {
        this._selector = null;
        if (!list) this._selectorList = [];
        else if (typeof  list == "string") list = list.split(',');
        if (list && list.map)this._selectorList = list.map(Style.trimSelector);
      }
    });
    Object.defineProperty(proto, 'value', {
      get: function () {
        var s = this.getBodyString();
        return s == '{}' ? undefined : this.selector + s;
      }
    });
    proto.addScope = function (scope) {
      if (scope instanceof Scope) {
        this.defValues = mix(this.defValues, scope.defValues);
        this.staticRules = mix(this.staticRules, scope.staticRules);
        this.dynamicRules = mix(this.dynamicRules, scope.dynamicRules);
        this.includes = mix(this.includes, scope.includes);
        this.exts.push.apply(this.exts, scope.exts);
        for (var i = 0, ns = scope.nested, children = this.nested, child = ns[0]; child; child = ns[++i]) {
          children.push(child);
          child.parent = this;
        }
      }
      return this;
    };
    proto.clone = function () {
      return new Style(this._selectorList, cloneFunc.apply(this));
    };
    return proto;
  })(Scope.prototype);
  Sheet.prototype = (function (proto) {
    var sheetProto = {};
    ['getFullString', 'assign', 'mixParam', 'addDefValues', 'recordUnresolvedInfo', 'add'].forEach(function (key) {
      sheetProto[key] = proto[key];
    });
    sheetProto.addStyle = function (style) {
      if (style instanceof Style)
        this.styles.push(style);
      return this;
    };
    Object.defineProperty(sheetProto, 'paramString', Object.getOwnPropertyDescriptor(proto, 'paramString'));
    function getExts(map, array, baseSelector) {
      if (array.indexOf(baseSelector) > -1) Error('cannot extends self:' + baseSelector);
      var r = array.slice();
      array.forEach(function (inherited) {
        var inheritedArray = map[inherited];
        if (inheritedArray instanceof Array) List.uniquePush(r, getExts(map, inheritedArray, baseSelector));
        else List.arrayAdd(r, inherited);
      });
      return r;
    }

    sheetProto.resolve = function ($vars, info) {
      var $unkonwn = {}, $param = this.assign($vars, info, $unkonwn), ctx = getContext(this, info), expMap = ctx.expMap, styles = this.styles, extArray;
      $param = mix($unkonwn, $param);
      styles.forEach(function (s) {
        ctx.setExtends(s);
      });
      return styles.reduce(function (resultArr, style) {
        style = style.clone();
        extArray = expMap[style.selector];
        if (extArray) {
          extArray = getExts(expMap, extArray, style.selector);
          if (extArray.length)
            style.selector += ',' + extArray.join(',');
        }
        List.uniquePush(resultArr, style.resolve($param, ctx));
        return resultArr;
      }, []);
    };
    function addExtends(map, baseSlt, extSlt) {
      var arr = map[baseSlt];
      if (!arr)arr = map[baseSlt] = [];
      List.arrayAdd(arr, extSlt);
    }

    function getContext(sheet, info) {
      var expMap = {};
      return {
        getMixScope: function (name) {
          return sheet.mixins[name];
        },
        info: info || {},
        get expMap() {
          return expMap;
        },
        setExtends: function (style) {
          var exts = style.exts, styleSlt = style.selector;
          if (exts)exts.forEach(function (ext) {
            addExtends(expMap, ext, styleSlt);
          });
        }
      };
    }

    sheetProto.toString = function ($vars) {
      var r = this.resolve($vars), add = List.arrayAdd;
      return r.reduce(function (pre, pair) {
        add(pre, pair.selector + pair.body);
        return pre;
      }, []).join('\n');
    };
    sheetProto.getBodyString = function ($vars, unresolvedInclude) {
      var info = {}, arg = this.assign($vars, info, true);
      return this.styles.map(function (style) {
        return style.toString(arg, unresolvedInclude);
      }).join('\n');
    };
    sheetProto.parse = function (string) {
      try {
        return parser.parse(string);
      }
      catch (e) {
        throw e;
      }
      finally {
        parser.lexer.popState();
      }
    };
    sheetProto.addMix = function (scope) {
      this.mixins[scope.name] = scope;
      return this;
    };

    return sheetProto;
  })(Scope.prototype);
  function mix() {
    for (var i = 0, o = {}, item = arguments[i]; item; item = arguments[++i])
      Object.getOwnPropertyNames(item).forEach(function (key) {
        o[key] = item[key];
      });
    return o;
  }

  function objForEach(obj, callback, thisObj, arg) {
    thisObj = thisObj || obj;
    if (typeof obj == "object" && obj)
      for (var i = 0, keys = Object.getOwnPropertyNames(obj), key = keys[0]; key !== undefined; key = keys[++i])
        callback.apply(thisObj, [key, obj[key], arg]);
    return obj;
  }

  (function (parser) {
    return parser.errorHandler = {
      expect: function (yy, char, ret, error) {
        var lexer = yy.lexer;
        if (lexer.upcomingInput() == char) return ret;
        else if (error)
          Error('expect:' + char + "after" + yy.matched);
        return false;
      }
    }
  })(parser);

  /* generated by jison-lex 0.3.4 */
  var lexer = (function () {
    var lexer = ({

      EOF: 1,

      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },

// resets the lexer, sets new input
      setInput: function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },

// consumes and returns one char from the input
      input: function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
      },

// unshifts one char (or a string) into the input
      unput: function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ?
            (lines.length === oldLines.length ? this.yylloc.first_column : 0)
            + oldLines[oldLines.length - lines.length].length - lines[0].length :
            this.yylloc.first_column - len
        };

        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },

// When called from action, caches matched text and appends it on next action
      more: function () {
        this._more = true;
        return this;
      },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function () {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });

        }
        return this;
      },

// retain first n characters of the match
      less: function (n) {
        this.unput(this.match.slice(n));
      },

// displays already matched input, i.e. for error messages
      pastInput: function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
      },

// displays upcoming input, i.e. for error messages
      upcomingInput: function () {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },

// displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },

// test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function (match, indexed_rule) {
        var token,
          lines,
          backup;

        if (this.options.backtrack_lexer) {
          // save context
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ?
            lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
            this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          // recover context
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
      },

// return next match in input
      next: function () {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }

        var token,
          match,
          tempMatch,
          index;
        if (!this._more) {
          this.yytext = '';
          this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue; // rule action called reject() implying a rule MISmatch.
              } else {
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },

// return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },

// pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },

// produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },

// alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },

// return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            return 'BREAKER';
            break;
          case 1:/* ignore*/
            ;
            break;
          case 2:
            return 40;
            break;
          case 3:
            return 26;
            break;
          case 4:
            this.begin("EXPRESSION");
            return 'NAMESPACE';
            break;
          case 5:
            this.begin('EXT');
            return 30;
            break;
          case 6:
            this.popState();
            return 31;
            break;
          case 7:
            return 5;
            break;
          case 8:
            return 31;
            break;
          case 9:/* ignore*/
            ;
            break;
          case 10:
            this.begin("EXPRESSION");
            return 22;
            break;
          case 11:
            return 32;
            break;
          case 12:
            this.popState();
            return 35;
            break;
          case 13:
            this.popState();
            return 36;
            break;
          case 14:
            return 10;
            break;
          case 15:
            return 11;
            break;
          case 16:
            return 22;
            break;
          case 17:
            return 16;
            break;
          case 18:
            return 37;
            break;
          case 19:
            return 4;
            break;
          case 20:
            this.popState();
            return 32;
            break;
          case 21:
            return "STRING";
            break;
          case 22:
            return "URL";
            break;
          case 23:
            return 6;
            break;
          case 24:
            return 7;
            break;
          case 25:
            return 8;
            break;
          case 26:
            return 9;
            break;
          case 27:
            return 19;
            break;
          case 28:
            return 13;
            break;
          case 29:
            return 19;
            break;
          case 30:
            return 28;
            break;
          case 31:
            return "EOF";
            break;
        }
      },
      rules: [/^(?:(={4,}|-{4,}))/, /^(?:(\/\*[\s\S]*?\*\/|\/\/.*?[\r\n]))/, /^(?:@mixin\b)/, /^(?:@include\b)/, /^(?:@namespace\b)/, /^(?:@extends([\s\r\n\t\f])*)/, /^(?:(([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>])((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>])|[\s>\+\~@\^\$\|\=\:\[\]\'\"\(\)\r\n\t\f])*?(?=;))/, /^(?:(\$(([_a-zA-Z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)))/, /^(?:((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>])((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>])|[\s>\+\~@\^\$\|\=\:\[\]\'\"\(\)\r\n\t\f])*?(?=(\((\$(([_a-zA-Z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)):)|\{|,)))/, /^(?:([\s\r\n\t\f]))/, /^(?::)/, /^(?:;+)/, /^(?:\{)/, /^(?:\})/, /^(?:\()/, /^(?:\))/, /^(?::)/, /^(?:,)/, /^(?:&:*((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>])((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>])|[\s>\+\~@\^\$\|\=\:\[\]\'\"\(\)\r\n\t\f])*?(?=(\((\$(([_a-zA-Z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)):)|\{|,)))/, /^(?:((\d+(\.\d+)?)|(\.\d+))(px|pc|px|in|cm|mm|deg|em|ex|%)?)/, /^(?:;+)/, /^(?:("|')[\s\S]*?(\1))/, /^(?:(url\(.*?\)|url\((("|')[\s\S]*?(\1))\)))/, /^(?:\+)/, /^(?:-)/, /^(?:\*)/, /^(?:\/)/, /^(?:#([0-9a-f])+)/, /^(?:(([_a-z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)(?=\())/, /^(?:(([_a-z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*))/, /^(?:(-?(([_a-z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)))/, /^(?:$)/],
      conditions: {"INITIAL": {"rules": [0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 30, 31], "inclusive": true}, "EXPRESSION": {"rules": [0, 1, 2, 3, 4, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31], "inclusive": true}, "EXT": {"rules": [0, 1, 2, 3, 4, 6, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 30, 31], "inclusive": true}}
    });
    return lexer;
  })();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }

  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = parser;
  exports.Parser = parser.Parser;
  exports.parse = function () {
    return parser.parse.apply(parser, arguments);
  };
  exports.main = function commonjsMain(args) {
    if (!args[1]) {
      console.log('Usage: ' + args[0] + ' FILE');
      process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
  };
  if (typeof module !== 'undefined' && require.main === module) {
    exports.main(process.argv.slice(1));
  }
}