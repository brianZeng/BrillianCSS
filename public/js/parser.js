/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,15],$V1=[1,14],$V2=[1,12],$V3=[1,11],$V4=[1,6],$V5=[1,4,31,39,46,48,51,52],$V6=[1,20],$V7=[1,4,24,31,39,46,48,51,52],$V8=[1,26],$V9=[1,24],$Va=[1,31],$Vb=[1,33],$Vc=[14,34,41],$Vd=[1,4,6,8,10,11,12,13,14,15,16,19,20,22,24,27,30,31,34,35,36,39,46,48,51,52],$Ve=[1,41],$Vf=[1,47],$Vg=[1,44],$Vh=[1,45],$Vi=[1,4,6,24,27,30,31,35,36,39,46,48,51,52],$Vj=[6,14,34],$Vk=[1,54],$Vl=[6,14,34,44],$Vm=[1,62],$Vn=[1,63],$Vo=[1,66],$Vp=[1,67],$Vq=[1,68],$Vr=[1,60],$Vs=[1,61],$Vt=[6,27,30,31,35,36],$Vu=[1,72],$Vv=[6,24,27,30,31,35,36],$Vw=[6,24,27,30,31,34,35,36],$Vx=[15,24],$Vy=[1,4,6,8,11,14,15,16,19,20,24,27,30,31,35,36,39,46,48,51,52],$Vz=[1,85],$VA=[1,86],$VB=[1,87],$VC=[1,88],$VD=[1,4,6,8,10,11,12,13,14,15,16,19,20,24,27,30,31,35,36,39,46,48,51,52],$VE=[1,4,6,8,10,11,14,15,16,19,20,24,27,30,31,35,36,39,46,48,51,52];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"var":3,"VAR":4,"->":5,"IDENT":6,"exp":7,"NUMBER":8,"inlineFunc":9,"+":10,"-":11,"*":12,"/":13,"(":14,")":15,"FUNCNAME":16,"list":17,"property":18,"STRING":19,"URL":20,"assignPair":21,":":22,"assignList":23,";":24,"defParamList":25,"includeCall":26,"INCLUDE":27,"scopeBodyPart":28,"nestedStyle":29,"EXTENDS":30,"SELECTOR":31,"scopeBody":32,"scope":33,"{":34,"}":35,"&":36,"style":37,"mixScope":38,"MIXIN":39,"selectors":40,",":41,"m_exp":42,"m_query":43,"M_ADD":44,"m_qlist":45,"MEDIA":46,"sheetPart":47,"KEYFRAMES":48,"sheet":49,"SHEET":50,"m_end":51,"EOF":52,"$accept":0,"$end":1},
terminals_: {2:"error",4:"VAR",5:"->",6:"IDENT",8:"NUMBER",10:"+",11:"-",12:"*",13:"/",14:"(",15:")",16:"FUNCNAME",19:"STRING",20:"URL",22:":",24:";",27:"INCLUDE",30:"EXTENDS",31:"SELECTOR",34:"{",35:"}",36:"&",39:"MIXIN",41:",",44:"M_ADD",46:"MEDIA",48:"KEYFRAMES",50:"SHEET",51:"m_end",52:"EOF"},
productions_: [0,[3,3],[3,1],[7,1],[7,1],[7,1],[7,3],[7,3],[7,3],[7,3],[7,2],[7,3],[9,3],[9,4],[18,1],[18,1],[18,1],[18,1],[17,1],[17,2],[21,3],[23,1],[23,3],[23,2],[25,2],[25,3],[26,3],[26,2],[28,3],[28,1],[28,1],[28,2],[28,4],[28,2],[32,1],[32,2],[33,3],[33,4],[33,3],[29,2],[29,1],[38,3],[40,1],[40,3],[37,2],[37,3],[42,3],[42,5],[43,1],[43,1],[43,3],[45,2],[45,3],[47,1],[47,2],[47,2],[47,1],[47,1],[47,2],[49,3],[49,1],[49,1],[49,2],[49,2],[49,2]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$=new Var($$[$0-2],$$[$0]);
break;
case 2:
this.$=new Var($$[$0]);
break;
case 3:
this.$=new Exp(new Length($$[$0]));
break;
case 4: case 5:
this.$=new Exp($$[$0]);
break;
case 6: case 7: case 8: case 9:
this.$= new Exp($$[$0-2],$$[$0-1],$$[$0]);
break;
case 10:
this.$=new Exp(new Length('0'),'-',$$[$0]);
break;
case 11: case 25: case 36:
this.$=$$[$0-1];
break;
case 12:
this.$=new InlineFunc($$[$0-2]);
break;
case 13:
this.$=new InlineFunc($$[$0-3],$$[$0-1].reduce());
break;
case 14:
this.$=$$[$0].resolve();
break;
case 15:
this.$=$$[$0][0]=='@'? $$[$0].substr(2,$$[$0].length-3):$$[$0];
break;
case 18: case 42:
this.$=new List($$[$0]);
break;
case 19:
$$[$0-1].push($$[$0]);
break;
case 20:
this.$={name:$$[$0-2],value:$$[$0].resolve()};
break;
case 21:
this.$={};this.$[$$[$0].name]=$$[$0].value
break;
case 22:
$$[$0-2][$$[$0].name]=$$[$0].value
break;
case 24:
this.$={};
break;
case 26:
this.$={name:$$[$0-1].toString(),value:$$[$0]};
break;
case 27:
this.$={name:$$[$0].toString(),value:{}};
break;
case 28:
this.$={name:$$[$0-2],value:$$[$0].resolve(),type:'rule'};
break;
case 29:
this.$={type:'style',value:$$[$0]};
break;
case 30:
$$[$0].type='include';
break;
case 31:
this.$={type:'ext',name:$$[$0]};
break;
case 32:
this.$={type:'ext',name:$$[$0-2],sheetName:$$[$0]};
break;
case 34:
this.$=new Scope().add($$[$0])
break;
case 35:
this.$=$$[$0-1].add($$[$0]);
break;
case 37:
this.$=$$[$0-1].addDefValues($$[$0-3]);
break;
case 38:
this.$=new Scope().addDefValues($$[$0-2]);
break;
case 39: case 44:
this.$=new Style($$[$0-1],$$[$0]);
break;
case 41:
this.$={name:$$[$0-1],value:$$[$0]}
break;
case 43: case 50:
$$[$0-2].add($$[$0]);
break;
case 45:
this.$=new Style($$[$0-2]);
break;
case 46:
this.$={key:$$[$0-1]};
break;
case 47:
this.$={key:$$[$0-3],value:$$[$0-1]};
break;
case 48:
this.$=new MediaQuery($$[$0]);
break;
case 49:
this.$=new MediaQuery('',$$[$0]);;
break;
case 51:
this.$=$$[$0];
break;
case 52:
$$[$0-2].merge($$[$0]);
break;
case 53:
this.$={type:'style',value:$$[$0]}
break;
case 54:
this.$={type:'style',value:$$[$0].asKeyFrames($$[$0-1])}
break;
case 55:
this.$={type:'style',value:$$[$0].asMediaQuery($$[$0-1].reduce())}
break;
case 56:
$$[$0].type='mix';
break;
case 57:
$$[$0].type='var';
break;
case 59:
this.$=new Sheet($$[$0-1]);
break;
case 60:
this.$=new Sheet().add($$[$0]);
break;
case 61:
this.$=new Sheet().add($$[$0],'style');
break;
case 62:
$$[$0-1].add($$[$0]);
break;
case 63:
$$[$0-1].add($$[$0],'style');
break;
case 64:
return this.$=$$[$0-1];
break;
}
},
table: [{3:13,4:$V0,21:9,31:$V1,37:5,38:8,39:$V2,40:10,45:7,46:$V3,47:3,48:$V4,49:1,50:[1,2],51:[1,4]},{1:[3],3:13,4:$V0,21:9,31:$V1,37:5,38:8,39:$V2,40:10,45:7,46:$V3,47:16,48:$V4,51:[1,17],52:[1,18]},{6:[1,19]},o($V5,[2,60],{24:$V6}),o($V5,[2,61]),o($V7,[2,53]),{31:$V1,37:21,40:10},{6:[1,23],14:$V8,25:25,33:22,34:$V9},o($V7,[2,56]),o($V7,[2,57]),{14:$V8,25:25,33:27,34:[1,28],41:[1,29]},{6:$Va,14:$Vb,42:32,43:30},{3:34,4:$V0},{22:[1,35]},o($Vc,[2,42]),o($Vd,[2,2],{5:[1,36]}),o($V5,[2,62],{24:$V6}),o($V5,[2,63]),o($V5,[2,64]),{24:[1,37]},o($V7,[2,58]),o($V7,[2,54]),o($V7,[2,55]),{6:$Va,14:$Vb,42:32,43:38},{6:$Ve,26:43,27:$Vf,28:40,29:42,30:$Vg,31:$V1,32:39,36:$Vh,37:46,40:10},{34:[1,48]},{3:13,4:$V0,15:[1,49],21:51,23:50},o($Vi,[2,44]),{6:$Ve,26:43,27:$Vf,28:40,29:42,30:$Vg,31:$V1,32:39,35:[1,52],36:$Vh,37:46,40:10},{31:[1,53]},o($Vj,[2,51],{44:$Vk}),o($Vl,[2,48]),o($Vl,[2,49]),{6:[1,55]},{14:$V8,25:25,33:56,34:$V9},{3:64,4:$V0,6:$Vm,7:59,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq,17:57,18:58,19:$Vr,20:$Vs},{6:[1,69]},o($V5,[2,59]),o($Vj,[2,52],{44:$Vk}),{6:$Ve,26:43,27:$Vf,28:71,29:42,30:$Vg,31:$V1,35:[1,70],36:$Vh,37:46,40:10},o($Vt,[2,34],{24:$Vu}),{22:[1,73]},o($Vv,[2,29]),o($Vv,[2,30]),{31:[1,74]},{14:$V8,25:25,33:75,34:$V9},o($Vv,[2,40]),{3:76,4:$V0},{6:$Ve,26:43,27:$Vf,28:40,29:42,30:$Vg,31:$V1,32:77,35:[1,78],36:$Vh,37:46,40:10},o($Vw,[2,24]),{15:[1,79],24:[1,80]},o($Vx,[2,21]),o($Vi,[2,45]),o($Vc,[2,43]),{14:$Vb,42:81},{15:[1,82],22:[1,83]},o($V7,[2,41]),o([1,15,24,31,39,46,48,51,52],[2,20],{7:59,3:64,9:65,18:84,4:$V0,6:$Vm,8:$Vn,11:$Vo,14:$Vp,16:$Vq,19:$Vr,20:$Vs}),o($Vy,[2,18]),o([1,4,6,8,14,15,16,19,20,24,27,30,31,35,36,39,46,48,51,52],[2,14],{10:$Vz,11:$VA,12:$VB,13:$VC}),o($Vy,[2,15]),o($Vy,[2,16]),o($Vy,[2,17]),o($VD,[2,3]),o($VD,[2,4]),o($VD,[2,5]),{3:64,4:$V0,7:89,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq},{3:64,4:$V0,7:90,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq},{14:[1,91]},o($Vd,[2,1]),o($Vi,[2,36]),o($Vt,[2,35],{24:$Vu}),o($Vv,[2,33]),{3:64,4:$V0,6:$Vm,7:59,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq,17:92,18:58,19:$Vr,20:$Vs},o($Vv,[2,31],{5:[1,93]}),o($Vv,[2,39]),o($Vv,[2,27],{25:94,14:$V8}),{6:$Ve,26:43,27:$Vf,28:71,29:42,30:$Vg,31:$V1,35:[1,95],36:$Vh,37:46,40:10},o($Vi,[2,38]),o($Vw,[2,25]),o($Vx,[2,23],{3:13,21:96,4:$V0}),o($Vl,[2,50]),o($Vl,[2,46]),{3:64,4:$V0,6:$Vm,7:59,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq,17:97,18:58,19:$Vr,20:$Vs},o($Vy,[2,19]),{3:64,4:$V0,7:98,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq},{3:64,4:$V0,7:99,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq},{3:64,4:$V0,7:100,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq},{3:64,4:$V0,7:101,8:$Vn,9:65,11:$Vo,14:$Vp,16:$Vq},o($VD,[2,10]),{10:$Vz,11:$VA,12:$VB,13:$VC,15:[1,102]},{3:64,4:$V0,6:$Vm,7:59,8:$Vn,9:65,11:$Vo,14:$Vp,15:[1,103],16:$Vq,17:104,18:58,19:$Vr,20:$Vs},o([24,27,30,31,35,36],[2,28],{7:59,3:64,9:65,18:84,4:$V0,6:$Vm,8:$Vn,11:$Vo,14:$Vp,16:$Vq,19:$Vr,20:$Vs}),{6:[1,105]},o($Vv,[2,26]),o($Vi,[2,37]),o($Vx,[2,22]),{3:64,4:$V0,6:$Vm,7:59,8:$Vn,9:65,11:$Vo,14:$Vp,15:[1,106],16:$Vq,18:84,19:$Vr,20:$Vs},o($VE,[2,6],{12:$VB,13:$VC}),o($VE,[2,7],{12:$VB,13:$VC}),o($VD,[2,8]),o($VD,[2,9]),o($VD,[2,11]),o($VD,[2,12]),{3:64,4:$V0,6:$Vm,7:59,8:$Vn,9:65,11:$Vo,14:$Vp,15:[1,107],16:$Vq,18:84,19:$Vr,20:$Vs},o($Vv,[2,32]),o($Vl,[2,47]),o($VD,[2,13])],
defaultActions: {},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

function popUntil(lexer,state){
  while(lexer.topState()!==state)
    lexer.popState();
}
/**
 * Created by 柏然 on 2014/11/1.
 */
ChangeSS = (function (parser) {
  var sheetMap = {}, getter, setter;
  main.error = {
    notExist: function (name) {
      throw Error('cannot get:' + name);
    }
  };
  function main(input, opt) {
    opt = opt || {keepResults: false};
    return evalInput(input, opt.keepResults).map(function (sheet) {
      return sheet.toString();
    }).join('\n');
  }

  main.eval = evalInput;
  function evalInput(input, keep) {
    if (!keep)clear();
    var results = List();
    main.parse(input).forEach(function (sheet) {
      results.add(merge(sheet));
    });
    ChangeSS.link(results);
    // debugger;
    return results;
  }
  function clear() {
    sheetMap = {};
  }

  function merge(obj) {
    if (obj instanceof Sheet) return getter.sheet(obj.name).merge(obj);
    else throw 'not implement';
  }

  main.merge = merge;

  main.get = function (name, type) {
    name = name || main.defaultSheetName;
    type = (type || '').toLowerCase();
    switch (type) {
      case 'mixin':
      case 'scope':
        return getter.fromFullName(name, type);
      case 'var':
        return getter.variable(name);
      case 'styles':
        return getter.styles(name);
      default :
        return getter.sheet(name);
    }
  };
  main.opt = {
    addKeyFramesVendorPrefix:true,
    preferKeyFramesVendorPrefix:true
  };
  main.opt.vendorPrefix=(function(){
    if(window&&window.getComputedStyle){
      for(var i= 0,styles=window.getComputedStyle(document.documentElement,''),pre,len=styles.length;i<len;i++){
        if(pre=styles[i].match(/-(moz|webkit|ms|o)-/))break;
      }
      if(pre)return pre[1];
      return styles.OLink? 'o':'';
    }
    return '';
  })();
  getter = {
    sheet: function (name) {
      name = name || main.defaultSheetName;
      var sheet = sheetMap[name];
      return sheet || (sheetMap[name] = new Sheet(name));
    },
    fromFullName: function (name, type) {
      var names = name.split('->'), sheetName = names[1], sheet;
      if (!sheetName)return undefined;
      if (!(sheet = sheetMap[sheetName]))return ChangeSS.error.notExist(name);
      return sheet.get(names[0], type) || ChangeSS.error.notExist(name);
    },
    variable: function (name) {
      var i = name.indexOf('->'), sheetName = name.substr(i + 2), symbol = name.substr(0, i), sheet;
      if (!sheetName || !(sheet = sheetMap[sheetName]) || !symbol)return undefined;
      return sheet.vars[symbol];
    },
    styles: function (globalName) {
      var i = globalName.indexOf('->'), sheet = sheetMap[globalName.substr(i + 2)] || ChangeSS.error.notExist(globalName);
      return sheet.getStyles(globalName.substr(0, i));
    }
  };
  setter = {
    Var: function (Var, value) {
      var sheet = getter.sheet(Var.sheetName);
      sheet.vars[Var.symbol] = value;
      Var.sheetName = '';
    },
    sheet: function (sheet) {
      var name = sheet.name || main.defaultSheetName, os = getter.sheet(name);
      os.merge(sheet);
    }
  };

  main.parse = function (input) {
    return input.split(/\={4,}/g).filter(function (src) {
      return src;
    }).map(function (src) {
      return parser.parse(src).validate();
    });
  };
  main.add = function (something, value) {
    if (something instanceof Sheet) setter.sheet(something);
    else if (something instanceof Var) setter.Var(something, value);
    return this;
  };
  main.getType = function (side, asNone) {
    var type;
    if (!side)return ChangeSS.TYPE.NONE;
    if (typeof side == "string") return ChangeSS.TYPE.KEYWORD;
    else if (type = side._type) return type;
    else if (asNone)return ChangeSS.TYPE.NONE;
    throw  Error('unknown type');
  };
  return main;
})(parser);
ChangeSS.defaultSheetName = 'default';
ChangeSS.assign = function ($param, $known) {
  var con, typeEnum = ChangeSS.TYPE, $unknown = mix($param);
  $known = mix($known);
  do {
    con = false;
    objForEach($unknown, function (key, value) {
      switch (ChangeSS.getType(value)) {
        case typeEnum.KEYWORD:
        case typeEnum.LENGTH:
          $known[key] = value;
          delete $unknown[key];
          break;
        case typeEnum.LIST:
          $unknown[key] = value = value.resolve($known);
          if (!value.hasVars) {
            $known[key] = value.toString();
            delete  $unknown[key];
          } else return;
          break;
        case typeEnum.NONE:
          throw 'unknown type';
        default :
          if (value.canResolve($known))
            $unknown[key] = value.resolve($known);
          else return;
      }
      con = true;
    });
    if (!con)
      con = Object.getOwnPropertyNames($unknown).some(function (key) {
        $unknown[key].canResolve($known)
      });
  } while (con);
  return {$resolved: $known, $unresolved: $unknown};
};
ChangeSS.traceLog = true;
function mix() {
  for (var i = 0, o = {}, item , len = arguments.length; i < len; i++)
    if (item = arguments[i])
    Object.getOwnPropertyNames(item).forEach(function (key) {
      o[key] = item[key];
    });
  return o;
}
function objForEach(obj, callback, thisObj, arg) {
  thisObj = thisObj || obj;
  if (typeof obj == "object" && obj)
    for (var i = 0, keys = Object.getOwnPropertyNames(obj), key = keys[0]; key !== undefined; key = keys[++i])
      callback.apply(thisObj, [key, obj[key], arg]);
  return thisObj;
}
(function (parser) {
  return parser.errorHandler = {
    expect: function (yy, char, ret, error) {
      var lexer = yy.lexer;
      if (lexer.upcomingInput() == char) return ret;
      else if (error)
        Error('expect:' + char + "after" + yy.matched);
      return false;
    }
  }
})(parser);
ChangeSS.TYPE = {
  NONE: 'no',
  EXP: 'exp',
  VAR: 'var',
  LENGTH: 'len',
  FUNC: 'fun',
  KEYWORD: 'keyword',
  LIST: 'list'
};/**
 * Created by 柏然 on 2014/11/1.
 */
function Length(str) {
  if (!(this instanceof Length)) return new Length(str);
  var m;
  if (!isNaN(str)) {
    this.num = parseFloat(str);
    this.unit = '';
  }
  if (typeof str == "string") {
    m = str.match(/^\-?((\d+(\.\d+)?)|(\.\d+))/);
    if (m) {
      this.num = parseFloat(m[0]);
      this.unit = str.substr(m[0].length);
    }
    else return str;
  }
}
Length.parse = function (str, unit) {
  if (str instanceof Length) return str.clone();
  var l = new Length(str);
  if (unit !== undefined) l.unit = unit.trim();
  return isNaN(l.num) ? undefined : l;
};
Length.toFixed = function (num, fractionalDititals) {
  var m = Number(num).toFixed(fractionalDititals || Length.fractionalDigitals).match(/^\-?\d+(\.(0*[1-9])+)?/);
  return m ? m[0] : NaN;
};
Length.fractionalDigitals = 4;
Length.convertTable = {
  rad: {
    pi: function (n) {
      return n / Math.PI;
    },
    deg: function (n) {
      return n / Math.PI * 180;
    }
  },
  deg: {
    pi: function (n) {
      return n / 180;
    },
    rad: function (n) {
      return n / 180 * Math.PI;
    }
  },
  pi: {
    rad: function (n) {
      return n * Math.PI;
    },
    deg: function (n) {
      return n * 180;
    }
  }
};
Length.prototype = {
  _type: ChangeSS.TYPE.LENGTH,
  clone: function () {
    return new Length(this.num + this.unit);
  },
  opt: function (opt, exp) {
    var num, unit = this.unit, otherUnit = exp.unit;
    if (!exp) return this.clone();
    if (otherUnit && unit !== otherUnit)
      num = exp.convert(otherUnit, unit);
    else num = exp.num;
    unit = unit || otherUnit;
    switch (opt) {
      case '+':
        return new Length(this.num + num + unit);
      case '-':
        return new Length(this.num - num + unit);
      case '*':
        return new Length(this.num * num + unit);
      case '/':
        return new Length(this.num / num + unit);
      default :
        throw  'unkonwn optor:' + opt;
    }
  },
  convert: function (otherUnit, thisUnit) {
    var num = this.num, func = Length.convertTable[(thisUnit || this.unit).toLowerCase()];
    if (func && (func = func[otherUnit.toLowerCase()]))return func(num);
    return num;
  },
  toString: function () {
    return isNaN(this.num) ? 'NaN' : (Length.toFixed(this.num) + this.unit);
  },
  reduce: function () {
    return this;
  },
  resolve: function () {
    return this.clone();
  },
  get value() {
    return this.toString();
  }
};
ChangeSS.Length = Length;/**
 * Created by 柏然 on 2014/11/1.
 */
function Var(symbol, sheetName) {
  if (!(this instanceof Var))return new Var(symbol, sheetName);
  this.symbol = symbol.trim();
  this.sheetName = sheetName || '';
}
Var.prototype = (function (TYPE) {
  var VAR = TYPE.VAR, getType = ChangeSS.getType, LEN = TYPE.LENGTH, KEYWORD = TYPE.KEYWORD;

  function isVar(obj) {
    return getType(obj, true) === VAR;
  }
  Var.isVar = isVar;
  return{
    _type: ChangeSS.TYPE.VAR,
    toString: function () {
      var sheetName = this.sheetName;
      return sheetName ? this.symbol + '->' + sheetName : this.symbol;
    },
    get hasVars() {
      return true;
    },
    clone: function () {
      return new Var(this.symbol, this.sheetName);
    },
    reduce: function () {
      return this;
    },
    findRef: function () {
      var value = this, cycle = new Graph();
      while (isVar(value) && value.sheetName) {
        if (cycle.hasVertex(value))
          ChangeSS.error.cyclicInherit(cycle.vertexes.map(function (v) {
            return '[' + v + ']->'
          }), cycle);
        cycle.addVertex(value);
        value = ChangeSS.get(value.toString(), 'var');
      }
      return value;
    },
    resolve: function ($vars) {
      var value, real = this.findRef();
      if (isVar(real) || real == undefined) {
        if ($vars)value = $vars[this.symbol];
      }
      else value = real;
      if (isVar(value))
        if (isVar(real = value.findRef()))return this.clone();
        else value = real;
      return value || this.clone();
    },
    getVar: function (array) {
      array = array || [];
      List.arrayAdd(array, this.symbol);
      return array;
    },
    canResolve: function ($param) {
      var t = getType(this.resolve($param));
      return t == LEN || t == KEYWORD;
    }
  }
})(ChangeSS.TYPE);

ChangeSS.Var = Var;/**
 * Created by 柏然 on 2014/11/1.
 */
function Exp(left, optor, right) {
  if (!(this instanceof Exp))return new Exp(left, optor, right);
  this.left = left;
  if (right)this.right = right;
  if (optor) this.optor = optor;
}
Exp.prototype = (function () {
  var TYPE = ChangeSS.TYPE;
  return {
    _type: TYPE.EXP,
    opt: function (opt, exp) {
      var left = this.left;
      if (left instanceof Length && exp instanceof Length)
        this.left = left.opt(opt, exp);
      else {
        this.optor = opt;
        this.right = exp;
      }
      return this;
    },
    get value() {
      if (this.hasVars) return undefined;
      switch (this.type) {
        case TYPE.KEYWORD:
        case TYPE.LENGTH:
          return this.left;
        case TYPE.FUNC:
        case TYPE.LIST:
          return this.left.value;
        default:
          return this.left.opt(this.optor, this.right);
      }
    },
    reduce: function () {
      var left = this.left.resolve(), right = this.right ? this.right.resolve() : undefined, rtype = ChangeSS.getType(right), ltype = ChangeSS.getType(left);
      if (rtype == TYPE.NONE) {
        if (ltype == TYPE.EXP) {
          this.left = left.left;
          this.right = left.right;
          this.optor = left.optor;
        }
        else {
          this.left = left;
          delete this.optor;
          delete this.right;
        }
      }
      else if (ltype == TYPE.LENGTH && rtype == ltype) {
        this.left = left.opt(this.optor, right);
        delete this.optor;
        delete this.right;
      }
      else {
        this.left = left;
        this.right = right;
      }
      return this.clearVarNames();
    },
    canResolve: function ($vars) {
      return this.getVar().every(function (v) {
        return v.canResolve($vars);
      });
    },
    clearVarNames: function () {
      delete this.variables;
      var left = this.left, right = this.right;
      if (left.clearVarNames)left.clearVarNames();
      if (right && right.clearVarNames)right.clearVarNames();
      return this;
    },
    get hasVars() {
      var a = this.getVar();
      return a.length > 0;
    },
    resolve: (function () {
      var TYPE = ChangeSS.TYPE, getType = ChangeSS.getType;

      function resolveSide(side, $param, exp) {
        switch (getType(side)) {
          case TYPE.VAR:
          case TYPE.FUNC:
          case TYPE.EXP:
          case TYPE.LIST:
            exp.clearVarNames();
            return side.resolve($param);
          case TYPE.KEYWORD:
          case TYPE.LENGTH:
            return side;
          case TYPE.NONE:
            return undefined;
        }
      }

      function clone(obj) {
        return obj.clone ? obj.clone() : obj;
      }

      return function ($resolved) {
        var left = resolveSide(this.left, $resolved, this), right = resolveSide(this.right, $resolved, this), ltype = getType(left), rtype = getType(right), ret;
        this.clearVarNames();
        if (rtype == TYPE.NONE)
          return clone(left);
        switch (ltype) {
          case TYPE.VAR:
          case TYPE.FUNC:
          case TYPE.EXP:
          case TYPE.LIST:
            return new Exp(clone(left), this.optor, clone(right));
        }
        switch (rtype) {
          case TYPE.VAR:
          case TYPE.FUNC:
          case TYPE.EXP:
          case TYPE.LIST:
            return new Exp(clone(left), this.optor, clone(right));
          case TYPE.LENGTH:
            if (ltype == TYPE.LENGTH) return clone(left).opt(this.optor, clone(right));
        }
        Error('invalid Exp:left->' + ltype + ';right->' + rtype);
      }

    })(),
    getVar: function (array) {
      var vars;
      if (!(vars = this.variables)) {
        var left = this.left, right = this.right;
        vars = this.variables = [];
        if (left instanceof Var) List.arrayAdd(vars, left);
        else if (left.getVar) left.getVar(vars);
        if (right)
          if (right instanceof Var)List.arrayAdd(vars, right);
          else if (right.getVar) right.getVar(vars);
      }
      array = array || [];
      vars.forEach(function (symbol) {
        List.arrayAdd(array, symbol)
      });
      return array;
    },
    clone: function () {
      var left = this.left, r = new Exp(left.clone ? left.clone(true) : left), right;
      if ((right = this.right) !== undefined) {
        r.right = right.clone ? right.clone(true) : right;
        r.optor = this.optor;
      }
      return r;
    },
    toString: function () {
      var left = this.left, right = this.right;
      if (typeof left !== "string") left = left.toString();
      if (right) {
        if (typeof right !== "string") right = right.toString();
        return left + this.optor + right;
      }
      return left;
    }
  };
})();
ChangeSS.Exp = Exp;/**
 * Created by 柏然 on 2014/11/1.
 */
function InlineFunc(name, paramList) {
  if (!(this instanceof InlineFunc))return new InlineFunc(name, paramList);
  this.name = name;
  this.param = paramList || new List();
}
objForEach(Math, function (key, fun, def) {
    if (typeof fun == "function") {
      var convertArg = def.arg[key], convertRes = def.res[key];
      this[key] = function (mathArg) {
        var v = Length.parse(fun.apply(Math, mathArg.map(function (len) {
          return convertArg ? convertArg(len) : len.num;
        })), mathArg[0].unit);
        return convertRes ? convertRes(v) : v;
      }
    }
  }, InlineFunc.Func = {},
  (function () {
    var types = [function (len) {
      return len.convert('rad')
    },
      function (len) {
        len.convert(len.unit = 'deg', 'rad');
        return len;
      },
      function (len) {
        len.unit = '';
        return len;
      }];
    return {
      arg: {sin: types[0], cos: types[0], tan: types[0]},
      res: {asin: types[1], acos: types[1], atan: types[1], sin: types[2], cos: types[2], tan: types[2]}
    }
  })());
InlineFunc.prototype = {
  _type: ChangeSS.TYPE.FUNC,
  getVar: function (array) {
    return this.param.getVar(array);
  },
  resolve: function ($vars, info) {
    var v = this.param.resolve($vars, info), func, name = this.name, ret;
    func = InlineFunc.Func[name];
    if (!(v instanceof List))v = new List(v);
    if (func && v.canResolve($vars))
      return func(v.map(function (p) {
        return Length.parse(p.resolve ? p.resolve($vars) : p)
      })).resolve();
    ret = new InlineFunc(this.name, v);
    return v.hasVars ? ret : ret.toString();
  },
  get value() {
    var v = this.paramValue;
    return v == undefined ? undefined : this.name + v;
  },
  reduce: function () {
    var p = this.param.resolve();
    this.param = p instanceof List ? p : new List(p);
    return this;
  },
  clone: function () {
    var p = this.param;
    return new InlineFunc(this.name, p.clone ? p.clone() : p);
  },
  canResolve: function ($vars) {
    var p = this.param;
    return typeof p == "string" ? true : p.canResolve($vars);
  },
  toString: function () {
    return this.name + this.paramString;
  },
  get paramString() {
    var v = this.param.toString();
    return '(' + v.replace(/\s+\,\s*/g, ',') + ')';
  },
  get paramValue() {
    var v = this.param.value;
    return v == undefined ? undefined : '(' + v.replace(/\s+/gi, ',') + ')';
  }
};
ChangeSS.InlineFunc = InlineFunc;/**
 * Created by 柏然 on 2014/11/1.
 */
function List() {
  if (!(this instanceof List))return List.fromArray(arguments);
  for (var i = 0, len = arguments.length; i < len; i++)
    this.add(arguments[i]);
}
List.addOrMerge = (function () {
  function merge(oriItem, newItem) {
    return newItem;
  }

  function getCompareFunc(keyOrFunc) {
    if (typeof keyOrFunc === 'string')return function (a, b) {
      return a[keyOrFunc] === b[keyOrFunc]
    };
    return keyOrFunc || function (a, b) {
      return a === b;
    }
  }

  return function (arr, obj, keyOrFunc, mergeFunc) {
    if (typeof mergeFunc !== "function")mergeFunc = merge;
    for (var i = 0, len = arr.length, compare = getCompareFunc(keyOrFunc), merged; i < len; i++)
      if (compare(obj, arr[i])) {
        merged = mergeFunc(arr[i], obj);
        if (merged !== undefined)arr[i] = merged;
        return arr;
      }
    arr.push(obj);
    return arr;
  }
})();
List.arrayAdd = function arrayAdd(array, item) {
  var r = true;
  if (item instanceof Array)
    for (var i = 0, len = item.length; i < len; i++) r &= arguments.callee(array, item[i]);
  else {
    if (array.indexOf(item) > -1)return false;
    else array.push(item);
  }
  return r;
};
List.uniquePush = function (a) {
  for (var i = 1, change = false, arr = arguments[1], add = List.arrayAdd; arr; arr = arguments[++i])
    for (var j = 0, len = arr.length; j < len; j++)
      if (add(a, arr[j]))change = true;
  return change;
};
List.fromObject = function (combiner, objArray) {
  if (!(objArray instanceof Array)) objArray = [objArray];
  for (var i = 0, list = new List, obj = objArray[0]; obj; obj = objArray[++i])
    Object.getOwnPropertyNames(obj).forEach(function (key) {
      list.push(key + combiner, obj[key]);
    });
  return list;
};
List.fromArray = function (arry) {
  var l = new List();
  Array.prototype.push.apply(l, arry);
  return l;
};
List.mapBy=(function(){
  function equal(a){
    return a;
  }
  return function(nameOrFunc){
    if(typeof nameOrFunc=="string")
      return function(a){return a[nameOrFunc]};
    else if(typeof nameOrFunc=="function")
      return function(a){return nameOrFunc(a);};
    return equal;
  }
})();
List.groupBy=function(arr,mapFuncOrName){
  var ids=[],mapBy=List.mapBy(mapFuncOrName),groups=[],id,item,index;
  for(var i= 0,len=arr.length;i<len;i++){
    index=ids.indexOf(id=mapBy(item=arr[i]));
    if(index==-1) {
      groups.push([item]);
      ids.push(id);
    }
    else groups[index].push(item);
  }
  return groups;
};
List.prototype = (function (proto) {
  proto.add = function (item) {
    if (this.indexOf(item) > -1)return false;
    this.push(item);
    return true;
  };
  proto.remove = function (item) {
    var i = this.indexOf(item);
    if (i > -1) {
      this.splice(i, 1);
      return true;
    }
    return false;
  };
  proto.canResolve = function ($vars) {
    $vars = $vars || {};
    return this.every(function (obj) {
      return (obj.canResolve) ? obj.canResolve($vars) : true;
    });
  };
  proto.clone = function () {
    return arrayReduce(this, function (list, o) {
      list.push(o.clone ? o.clone(true) : o);
      return list;
    }, new List());
  };
  proto.copy = function (array) {
    if (Array.isArray(array)) {
      this.splice(0, this.length);
      Array.prototype.push.apply(this, array);
    }
    else {
      this.splice(0, this.length, array);
    }
    return this;
  };
  proto.resolve = function ($vars) {
    var list = new List(), last;
    this.forEach(function (v) {
      last = list[list.length - 1];
      v = v.resolve ? v.resolve($vars) : v;
      if (typeof v == "string" && typeof last == "string")
        list[list.length - 1] = last + ' ' + v;
      else list.push(v);
    });
    if (list.length == 1)
      return list[0].resolve ? list[0].resolve($vars) : list[0];
    return list;
  };
  proto.getVar = function (array) {
    array = array || [];
    this.forEach(function (o) {
      if (o.hasVars)o.getVar(array)
    });
    return array;
  };
  Object.defineProperty(proto, 'value', {
    get: function () {
      for (var i = 0, r = [], v, item = this[0]; item; item = this[++i]) {
        v = item.resolve ? item.resolve() : item;
        if (v == undefined) return undefined;
        r.push(v);
      }
      return r.length ? r.join(' ').replace(/[\s\r\n\t\f]+/g, ' ').replace(/\,+/g, ',') : '';
    }
  });
  Object.defineProperty(proto, 'resolved', {
    get: function () {
      return this.every(function (v) {
        return v instanceof Length || typeof v == "string";
      })
    }
  });
  Object.defineProperty(proto, 'hasVars', {
    get: function () {
      return this.some(function (o) {
        return o.hasVars
      })
    }});
  proto.toString = function () {
    return this.join(' ').replace(/[\r\n\s\t\f]+/gi, ' ');
  };
  var arrayReduce = function (array, callback, initialValue) {
    return Array.prototype.reduce.apply(array, [callback, initialValue]);
  };
  proto.reduce = function (callback, initialValue) {
    if (arguments.length == 0)
      return this.copy(this.map(function (obj) {
        return obj.reduce ? obj.reduce() : obj
      }));
    else
      return arrayReduce(this, callback, initialValue);
  };
  proto.toParamList = function () {
    return this.copy(this.reduce().filter(function (c) {
      return c != ',';
    }));
  };
  proto._type = ChangeSS.TYPE.LIST;

  return proto;
})(Object.create([]));
ChangeSS.List = List;/**
 * Created by 柏然 on 2014/11/1.
 */
function Scope() {
  this.staticRules = {};
  this.dynamicRules = {};
  this.defValues = {};
  this.includes = {};
  this.nested = [];
  this.exts = [];
}
(function (def) {
  function trimSelector(selector) {
    return selector.replace(/[\r\n\t\f\s]+/gi, ' ').trim();
  }

  function splitGlobalName(name) {
    return name.split('->').map(trimSelector);
  }

  def.trimSelector = trimSelector;
  def.splitGlobalName = splitGlobalName;
})(Scope);

Scope.prototype = {
  selectors: [''],
  toString: (function () {
    function mapResult(separator) {
      separator = separator || window ? '\n' : '';
      return function (r) {
        return r.selector + '{' + separator + rules(r).join(separator) + '}';
      }
    }
    function rules(ruleObj) {
      return objForEach(ruleObj, function (key, value) {
        this.push(key + ':' + value + ';');
      }, []);
    }
    return function ($vars, separator) {
      return this.resolve($vars).map(mapResult(separator));
    }
  })(),
  get globalName() {
    var sheetName = this.sheetName;
    if (!sheetName)return undefined;
    return (this.symbol || this.selector) + '->' + sheetName;
  },
  setSheetName: function (name) {
    this.sheetName = name;
    this.nested.forEach(function (s) {
      s.setSheetName(name)
    });
  },
  get paramString() {
    var r = [];
    objForEach(this.defValues, function (key, value) {
      r.push(key + ':' + value);
    });
    return r.length ? '(' + r.join(',') + ')' : '';
  },
  add: function (obj) {
    switch (obj.type.toLowerCase()) {
      case 'rule' :
        return this.addRule(obj.name, obj.value);
      case 'def':
        return this.addDefValues(obj.name, obj.value);
      case 'style':
        return this.addStyle(obj.value);
      case 'include':
        return this.addInclude(obj.name, obj.value);
      case 'ext':
        return this.addExt(obj.name, obj.sheetName);
      case 'mix':
        return this.addMix(obj.value);
    }
    return this;
  },
  addExt: function (selector, sheetName) {
    var names = selector.split('->').map(Scope.trimSelector);
    selector = names[0];
    sheetName = sheetName || names[1];
    if (sheetName)selector += '->' + sheetName;
    List.arrayAdd(this.exts, selector);
    return this;
  },
  addRule: function (key, value) {
    if (value.hasVars) this.dynamicRules[key] = value;
    else this.staticRules[key] = value.toString();
    return this;
  },
  addDefValues: function (objOrkey, value) {
    var v;
    if (typeof objOrkey == "string") {
      if (value instanceof List && value.length == 1)value = value[0];
      else if (value.resolve) v = value.resolve();
      this.defValues[objOrkey] = Length.parse(v) || value;
    }
    else objForEach(objOrkey, function (key, v) {
      this.addDefValues(key, v);
    }, this);
    return this;
  },
  addStyle: function (style) {
    if (style instanceof Scope) {
      this.nested.push(style);
      if (this.sheetName)style.setSheetName(this.sheetName);
    }
    return this;
  },
  addInclude: function (varName, rules) {
    this.includes[varName] = rules;
    return this;
  },
  asContainer:function(){
    this.selectors=[''];
    var nested=this.nested,def=this.defValues;
    Scope.apply(this);
    nested.forEach(function(s){s.validateSelector()});
    this.nested=nested;
    this.defValues=def;
    return this;
  },
  asMediaQuery:function(mediaQuery){
    this.asContainer().spec=mediaQuery;
    return this;
  },
  canResolve: function ($vars) {
    $vars = this.mixParam($vars || {});
    return Object.getOwnPropertyNames(this.dynamicRules).every(function (key) {
      return this[key].canResolve($vars);
    }, this.dynamicRules);
  },
  validateSelector: (function () {
    function second() {
      return this.selectors;
    }

    function backtrackSelector(parentSelectors) {
      var r, tss;
      if (parentSelectors) {
        tss = this.selectors;
        r = [];
        parentSelectors.forEach(function (ps) {
          tss.forEach(function (ts) {
            ts = ts.replace(ps, '');
            r.push(ts[0] == ' ' ? ts.substr(1) : '&' + ts);
          })
        });
        tss = this.selectors;
        this.selectors = r;
      } else tss = this.selectors;
      this.nested.forEach(function (s) {
        s.backtraceSelector(tss);
      });
      this._selector = null;
      this.backtraceSelector = second;
      this.validateSelector = first;
      return this.selectors;
    }

    function first(parentSelectors) {
      var r, tss;
      if (parentSelectors) {
        r = [];
        tss = this.selectors;
        parentSelectors.forEach(function (ps) {
          tss.forEach(function (ts) {
            r.push(ts[0] == '&' ? ts.replace('&', ps) : ps + ' ' + ts);
          })
        });
        this.selectors = r;
      }
      else r = this.selectors;
      this.nested.forEach(function (scope) {
        scope.validateSelector(r)
      });
      this._selector = null;
      this.validateSelector = second;
      this.backtraceSelector = backtrackSelector;
      return r;
    }
    return first;
  })(),
  backtraceSelector: function () {
    return this.selectors;
  },
  clone: (function () {
    function onPair(key, value) {
      this[key] = value.clone ? value.clone(true) : value;
    }
    return function () {
      var r = new Scope();
      r.validateSelector();
      objForEach(this.staticRules, onPair, r.staticRules);
      objForEach(this.dynamicRules, onPair, r.dynamicRules);
      objForEach(this.defValues, onPair, r.defValues);
      objForEach(this.includes, onPair, r.includes);
      r.nested = this.nested.map(function (scope) {
        return scope.clone();
      });
      r.exts = this.exts.slice();
      r.selectors = this.selectors.slice();
      return r;
    }
  })(),
  reduce: function () {
    var staticRules = this.staticRules, v;
    objForEach(this.dynamicRules, function (key, value) {
      v = value.value;
      if (v !== undefined) {
        delete this[key];
        staticRules[key] = v;
      }
    });
    return this;
  },
  remove: function (key) {
    if (Exp.isVar(key)) return delete this.defValues[key];
    if (this.staticRules.hasOwnProperty(key))return delete this.staticRules[key];
    if (this.dynamicRules.hasOwnProperty(key))return delete this.dynamicRules[key];
  },
  getVar: function (array) {
    array = array || [];
    objForEach(this.dynamicRules, function (key, value) {
      value.getVar(array);
    });
    return array;
  },
  /**
   * @function
   * @param  [object] $vars
   * @return {array<object>}
   */
   resolve: (function () {
    var keepEmptyResult = false;
    Object.defineProperty(ChangeSS.opt, 'keepEmptyResult', {
      set: function (v) {
        keepEmptyResult = !!v;
      },
      get: function () {
        return keepEmptyResult
      }});
    function log() {
      if (ChangeSS.traceLog)
        console.log.apply(console, arguments);
    }

    function resolveScope(scope, paramStack, $assign) {
      var $vars = assignParam(scope, true, paramStack, $assign), ruleObj = mix(scope.staticRules),
        selector = scope.selectors.join(','), r, $resolved = $vars.$resolved;
      objForEach(scope.dynamicRules, function (key, rule) {
        if (!ruleObj.hasOwnProperty(key) && rule.canResolve($resolved))
          ruleObj[key] = rule.resolve($resolved).toString();
        else log('cannot resolve rule ' + key + ':' + rule + ' in:', scope);
      });
      r = [
        {rules: ruleObj, selector: selector}
      ];
      objForEach(scope.includes, function (key, invokeParam) {
        var mixin = ChangeSS.get(key, 'mixin') || ChangeSS.error.notExist(key), $param = {};
        objForEach(ChangeSS.assign(invokeParam, $resolved).$resolved, function (key, value) {
          if (invokeParam[key])$param[key] = value;
        });
        resolveInclude(mixin, $param, selector).forEach(function (resObj) {
          if (objNotEmpty(resObj.rules))List.addOrMerge(r, resObj, 'selector', mergeResult);
        });
      });
      return r.filter(function (pair) {
        return keepEmptyResult || objNotEmpty(pair.rules);
      });
    }

    function mergeResult(a, b) {
      if (objNotEmpty(b.rules))
        a.rules = mix(b.rules, a.rules);
      return a;
    }

    function resolveInclude(mixObj, $vars, selector) {
      mixObj.selectors = selector.split(',');
      mixObj.validateSelector();
      var r = mixObj.resolve($vars);
      mixObj.backtraceSelector();
      return r;
    }
    function getChild(parent, child) {
      if (parent === child || !parent)return 0;
      return parent.nested[parent.nested.indexOf(child) + 1] || 0;
    }

    function preVisit(scope, $assign) {
      var childScope = 0, results = [], scopeStack = [], paramStack = [];
      do {
        if (childScope = getChild(scope, childScope)) {
          scopeStack.push(scope);
          paramStack.push(assignParam(scope, false, paramStack, $assign));
          scope = childScope;
          childScope = 0;
        }
        else {
          results.unshift.apply(results, resolveScope(scope, paramStack, $assign));
          scope = getChild(scopeStack[scopeStack.length - 1], scope);
          if (!scope) {
            childScope = scope = scopeStack.pop();
            paramStack.pop();
          }
        }
      } while (scope);

      return results;
    }

    function assignParam(scope, resolve, paramStack, $assign) {
      var lastAssign = paramStack[paramStack.length - 1] || {},
        $mix = mix(lastAssign, scope.defValues, $assign);
      return resolve ? ChangeSS.assign($mix) : $mix;
    }

    function objNotEmpty(obj) {
      return obj && Object.getOwnPropertyNames(obj).length > 0;
    }
    return function ($vars) {
      if (!$vars)$vars = {};
      else if ($vars.$resolved)$vars = mix($vars.$unresolved, $vars.$resolved);
      return preVisit(this, $vars);
    }
  })()
};
ChangeSS.Scope = Scope;
function Style(selectors, scope) {
  Scope.apply(this);
  this.selector = selectors;
  this.addScope(scope || new Scope());
}

Style.prototype = (function (scopeProto) {
  var cloneFunc = scopeProto.clone, proto;
  proto = Object.create(scopeProto);
  Object.defineProperty(proto, 'selector', {
    get: function () {
      return this._selector || (this._selector = this.selectors.join(','));
    },
    set: function (list) {
      if (typeof  list == "string") list = list.split(',');
      if (list) {
        if (list.map)
          this.selectors = list.map(Scope.trimSelector);
        else this.selectors = [Scope.trimSelector(list)];
        this._selector = null;
      }
    }
  });

  proto.addScope = function (scope) {
    if (scope instanceof Scope) {
      this.defValues = mix(this.defValues, scope.defValues);
      this.staticRules = mix(this.staticRules, scope.staticRules);
      this.dynamicRules = mix(this.dynamicRules, scope.dynamicRules);
      this.includes = mix(this.includes, scope.includes);
      this.exts.push.apply(this.exts, scope.exts);
      for (var i = 0, ns = scope.nested, children = this.nested, child = ns[0]; child; child = ns[++i])
        children.push(child);
    }
    return this;
  };
  proto.clone = function () {
    return new Style(this.selectors, cloneFunc.apply(this));
  };
  proto.getStyles = function (id) {
    var s;
    if (id.indexOf(s = this.selector) == 0)
      if (id === s)
        return [this];
      else
        return this.nested.reduce(function (pre, style) {
          pre.push.apply(pre, style.getStyles(id));
          return pre;
        }, []);
    else
      return [];
  };

  function filterKeyFrame(r){return /^(\d+\%|from|to)\s*$/.test(r.selector);}
  function keyFrameResolve(){
    return proto.resolve.apply(this,arguments).filter(filterKeyFrame);
  }
  proto.asKeyFrames=function(prefix){
    this.spec=new KeyFrame(this.selector,prefix);
    this.resolve=keyFrameResolve;
    return this.asContainer();
  };
  return proto;
})(Scope.prototype);/**
 * Created by 柏然 on 2014/11/1.
 */
function Sheet(name) {
  this.name = name || ChangeSS.defaultSheetName;
  this.scopes = [];
  this.mixins = {};
  this.vars = {};
}

Sheet.prototype = (function (proto) {
  proto.add = function (sheetPart, type) {
    var $key, ref;
    type = type || sheetPart.type;
    if (sheetPart instanceof Array)
      sheetPart.forEach(function (p) {
        this.add(p, type);
      }, this);
    else if (type == 'var') {
      ref = sheetPart.value;
      $key = sheetPart.name;
      if ($key.sheetName == this.name)$key.sheetName = '';
      if (Var.isVar(ref) && !ref.sheetName)ref.sheetName = this.name;
      this.vars[$key.toString()] = sheetPart.value;
    }
    else if (type == 'style') {
      ref = sheetPart instanceof Style ? sheetPart : sheetPart.value;
      this.scopes.push(ref);
      ref.setSheetName(this.name);
    }
    else if (type == 'mix') {
      var mixObj = sheetPart.value;
      $key = sheetPart.name;
      if ($key.sheetName == this.name) $key.sheetName = '';
      mixObj.symbol = $key.symbol;
      mixObj.isMixin = true;
      mixObj.setSheetName(this.name);
      this.mixins[$key.toString()] = mixObj;
    }
    else throw 'unknown type';
    return this;
  };
  proto.resolve = function ($vars) {
    var $assign = ChangeSS.assign(mix(this.vars, $vars)), $param = mix($assign.$unresolved, $assign.$resolved),r={};/*,
    reduceFunc= function(scopes){
         return scopes.reduce(function(pre,scope){
           pre.push.apply(pre,scope.resolve($param));
           return pre;
         },[]);
     };*/
    this.scopes.forEach(function(scope){
      var spec=scope.spec,key,result;
      if(spec===undefined)r['*']=scope.resolve($param);
      else if(spec instanceof MediaQuery&&typeof (key=spec.resolve($assign.$resolved))=="string")
        r[key+'{*}']=scope.resolve($param);
      else if(spec instanceof KeyFrame)
      {
        result=scope.resolve($param);
        spec.getAnimations().forEach(function(key){r[key+'{*}']=result});
      }
    });
    /* List.groupBy(this.scopes,'media').forEach(function(group){
      var media=group[0].media,key,gresults=reduceFunc(group);
      if(media===undefined)r["*"]=gresults;
      else if(typeof (key=media.resolve($assign.$resolved))==="string")
        r[key+'{*}']=gresults;
      else if(key instanceof  Array)
        key.forEach(function(k){r[k+'{*}']=gresults.slice()});
    });
    return this.scopes.reduce(function (r, scope) {
      r.push.apply(r, scope.resolve($param));
      return r;
    }, []);*/
    return r;
  };
  proto.toString =(function(){
    var separator='\n';
    function mapScope(scope){
      var rules = [], brc;
      objForEach(scope.rules, function (key, value) {rules.push(key + ':' + value + ';');});
      brc=rules.length? '{'+separator+'*'+separator+'}':'{*}';
      return scope.selector+brc.replace('*',rules.join(separator));
    }
    function mapGroup(group){
      return group.map(mapScope).join(separator);
    }
    return function($vars){
      var groups=this.resolve($vars),r=[],keyRep='{'+separator+'*'+separator+'}';
      objForEach(groups,function(key,group){
        key=key.replace('{*}',keyRep);
        r.push(key.replace('*',mapGroup(group)))
      });
      return r.join(separator);
    }
  })();/* function ($vars) {
    return this.resolve($vars).map(function (r) {
      var rules = [], brc;
      objForEach(r.rules, function (key, value) {
        rules.push(key + ':' + value + ';')
      });
      brc = rules.length ? '{\n*\n}' : '{*}';
      return r.selector + brc.replace('*', rules.join('\n'));
    }).join('\n');
  };*/
  proto.merge = function (sheet) {
    this.vars = mix(this.vars, sheet.vars);
    this.scopes = this.scopes.concat(sheet.scopes.map(function (s) {
      var sc = s.clone();
      if (s.sheetName)sc.setSheetName(s.sheetName);
      return sc;
    }));
    this.mixins = mix(this.mixins, sheet.mixins);
    return this;
  };
  proto.validate = function () {
    this.scopes.forEach(function (scope) {
      scope.validateSelector();
    });
    return this;
  };
  proto.get = function (id, type) {
    if (type == 'scope' || id[0] != '$') {
      for (var i = 0, scopes = this.scopes, scope = scopes[0]; scope; scope = scopes[++i])
        if (scope.selector == id) return scope;
    } else if (type == 'mixin')
      return this.mixins[id];
    else if (type == 'var')return this.vars[id];
    else return this.mixins[id] || this.vars[id];
  };
  proto.getStyles = function (id) {
    return this.scopes.reduce(function (pre, style) {
      pre.push.apply(pre, style.getStyles(id));
      return pre;
    }, []);
  };
  return proto;
})({});/**
 * Created by 柏然 on 2014/11/21.
 */
function MediaQuery(mType, condition) {
  if (!(this instanceof MediaQuery))return new MediaQuery(mType, condition);
  this.mediaTypes = [mType || ''];
  this.conditions = [
    {}
  ];
  this.groupPrefix='@media';
  this.add(condition);
}
MediaQuery.prototype = {
  add: function (pair, mediaType) {
    var i;
    if (mediaType == undefined) i = 0;
    else if ((i = this.mediaTypes.indexOf(mediaType)) == -1)return this;
    if (pair && pair.key)
      this.conditions[i][pair.key] = pair.value;
    return this;
  },
  merge: function (mq) {
    this.mediaTypes = this.mediaTypes.concat(mq.mediaTypes);
    this.conditions = this.conditions.concat(mq.conditions);
    return this;
  },
  apply: function (item) {
    if (item instanceof Array)
      item.forEach(function (i) {
        this.apply(i)
      }, this);
    else if (item instanceof Style) {
      item.media = this;
    }
    return this;
  },
  reduce: function () {
    this.conditions.forEach(function (con) {
      objForEach(con, function (key, v) {
        if(v==undefined)con[key]=v;
        else {
          if (v.resolve)v = v.resolve();
          con[key] = v.hasVars ? v : v.toString();
        }
      });
    });
    this.variables = null;
    return this;
  },
  clone: (function () {
    function cloneObj(obj) {
      var o = {};
      objForEach(obj, function (key, value) {
        o[key] = value.clone ? value.clone() : value
      });
      return o;
    }
    return function () {
      var m = new MediaQuery();
      m.mediaTypes = this.mediaTypes.slice();
      m.conditions = this.conditions.map(cloneObj);
      m.groupPrefix=this.groupPrefix;
      return m;
    }
  })(),
  toString: (function () {
    var MEDIA_AND=' and ';
    function resolveMedia(conMap, $known) {
      var r = [];
      objForEach(conMap, function (key, value) {
        if(value==undefined) r.push('('+key+')');
        else{
          if (value.hasVars)value = value.resolve($known);
          r.push('(' + key + ':' + value + ')');
        }
      });
      return r.join(MEDIA_AND);
    }

    return function ($vars) {
      var $known =$vars? ChangeSS.assign($vars).$resolved:{}, cons = this.conditions;
      return this.groupPrefix+' '+ this.mediaTypes.map(function (m_type, i) {
        var mcon=resolveMedia(cons[i], $known);
        if(m_type)
          return mcon? m_type+MEDIA_AND+mcon:m_type;
        return mcon;
        //return m_type?   m_type+MEDIA_AND+mcon  : mcon;
      }).join(',');
    }
  })(),
  canResolve: function ($vars) {
    return !this.hasVars || this.variables.every(function (v) {
      return v.canResolve($vars)
    });
  },
  get hasVars() {
    var vs = this.variables || (this.variables = this.getVar());
    return vs.length > 0;
  },
  getVar: function (array) {
    array = array || [];
    this.conditions.forEach(function (condition) {
      objForEach(condition, function (key, v) {
        if (v instanceof Var) List.arrayAdd(array, v);
        else if (v.getVar) v.getVar(array);
      });
    });
    return array;
  }
};
MediaQuery.prototype.resolve = function ($vars) {
  return this.canResolve($vars) ? this.toString($vars) : this.clone();
};
ChangeSS.MediaQuery = MediaQuery;
function KeyFrame(name,prefix){
  this.name=name;
  this.prefix=prefix;
}
KeyFrame.prototype=(function(){
  var vendorPrefixes=['o','moz','ms','webkit',''].map(mapPrefix),normalizePrefixes=['@keyframes'];
  function mapPrefix(pre){
    if(pre)pre='-'+pre+'-';
    return '@'+pre+'keyframes';
  }
  return {
    toString:function(){
      return this.prefix+' '+this.name;
    },
    getAnimations:function(){
      var prefix,name=this.name,r;
      if((prefix=this.prefix)===normalizePrefixes[0]){
        if(ChangeSS.opt.addKeyFramesVendorPrefix) r=vendorPrefixes;
        else r= ChangeSS.opt.preferKeyFramesVendorPrefix? [mapPrefix(ChangeSS.opt.vendorPrefix)]:normalizePrefixes;
      }
      else r= [prefix];
      return r.map(function(pre){return pre+' '+name});
    }
  }
})();/**
 * Created by 柏然 on 2014/11/6.
 */
function Graph() {
  if (!(this instanceof Graph))return new Graph();
  this.vertexes = this.createList();
  this.adjustList = this.createList();
}
Graph.prototype = {
  createList: function () {
    return new List()
  },
  addVertex: function (data) {
    for (var i = 0, len = arguments.length; i < len; i++)
      if (this.vertexes.add(arguments[i]))
        this.adjustList.push(this.createList());
    return this;
  },
  removeVertex: function (data) {
    var i = this.vertexIndex(data);
    if (i > -1) {
      this.vertexes.splice(i, 1);
      this.adjustList.slice(i, 1);
    }
    return this;
  },
  hasVertex: function (data) {
    return this.vertexes.indexOf(data) > -1;
  },
  isIsolated: function (data) {
    var i = this.vertexIndex(data);
    return i > -1 ? this.adjustList[i].length == 0 : undefined;
  },
  vertexIndex: function (data) {
    return this.vertexes.indexOf(data);
  },
  addEdge: function (from, to) {
    if (from === to)  ChangeSS.error.cyclicInherit([from, to]);
    this.addVertex(from, to).adjustList[this.vertexIndex(from)].add(this.vertexIndex(to));
    return this;
  },
  addEdges: function (arr) {
    for (var i = 0, len = arr.length; i < len; i += 2)
      this.addEdge(arr[i], arr[i + 1]);
    return this;
  },
  removeEdge: function (from, to, removeIsolated) {
    var arr = this.adjustList[this.vertexIndex((from))];
    if (arr)return arr.remove(this.vertexIndex(to));
    if (removeIsolated) {
      if (this.isIsolated(from))this.removeVertex(from);
      if (this.isIsolated(to))this.removeVertex(to);
    }
    return this;
  },
  adjustVertexes: function (data) {
    var vs = this.vertexes;
    return this.adjustList[this.vertexes.indexOf(data)].map(function (index) {
      return vs[index]
    });
  },
  mergePaths: (function () {
    function isSubSet(set, superSet) {
      var dis, i, setLen;
      if ((dis = superSet.length - (setLen = set.length)) <= 0)return false;
      for (i = 0; i < setLen; i++)
        if (set[i] !== superSet[dis + i])return false;
      return true;
    }

    return function (paths) {
      var con = 1, len;
      paths.sort(function (a, b) {
        return a.length > b.length
      });
      while (con) {
        con = 0;
        len = paths.length;
        paths = paths.filter(function (p, i) {
          for (i; i < len; i++)
            if (isSubSet(p, paths[i]))
              return !(con = 1);
          return true;
        });
      }
      return paths;
    }
  })(),
  convertPathsData: function (paths) {
    var vs = this.vertexes;
    return paths.map(function (arr) {
      return arr.map(function (i) {
        return vs[i];
      })
    });
  },
  detectCircle: (function () {
    var all = [];

    function deepVisit(preArray, dir, circle) {
      var from = dir.from;
      if (circle)return circle;
      if (preArray.indexOf(from) > -1) {
        preArray.push(from);
        return preArray;
      }
      preArray.push(from);
      for (var i = 0, to = dir.to, len = to.length; i < len && !circle; i++)
        circle = deepVisit(preArray.slice(), all[to[i]]);
      return circle;
    }

    return function (dirs) {
      all = dirs.reduce(function (pre, dir) {
        pre[dir.from] = dir;
        return pre;
      }, []);
      for (var d = 0, dir = dirs[0], circle; dir && !circle; dir = dirs[++d])
        circle = deepVisit([], dir, circle);
      return circle;
    }
  })(),
  getPaths: function (circleCollector) {
    var adsl = this.adjustList, vers = this.vertexes, dirs = vers.map(function (data, i) {
        return {from: i, to: adsl[i].slice()};
      }),
      endPaths = new Array(dirs.length), con = 1, temPaths = new Array(dirs.length), cir;
    for (var i = 0, len = dirs.length; i < len; i++)
      temPaths[i] = [];
    while (con) {
      con = false;
      dirs = dirs.filter(function (dir) {
        var from = dir.from, temPath;
        if (dir.to.length == 0) {
          temPath = temPaths[from];
          if (!temPath) return false;
          endPaths[from] = temPath.length ? temPath.map(function (p) {
            return [from].concat(p);
          }) : [
            [from]
          ];
          con = !(temPaths[from] = 0);
          return false;
        }
        else
          dir.to = dir.to.filter(function (toIndex) {
            var toEndPaths = endPaths[toIndex];
            if (toEndPaths) {
              temPaths[from] = temPaths[from].concat(toEndPaths);
              return !(con = true);
            }
            return true;
          });
        return true;
      });
    }
    if (dirs.length) {
      cir = this.detectCircle(dirs).map(function (i) {
        return vers[i];
      });
      if (circleCollector instanceof Array) circleCollector.push.apply(circleCollector, cir);
      else throw Error('circle detected:' + cir.join('->'));
    }
    return this.convertPathsData(this.mergePaths(endPaths.reduce(function (pre, arr) {
      pre.push.apply(pre, arr);
      return pre;
    }, [])));
  }
};
ChangeSS.Graph = Graph;
ChangeSS.link = (function () {
  ChangeSS.error.cyclicInherit = function (pathInfo, graph) {
    throw Error('Cyclic inherits detected:' + pathInfo);
  };
  function reportCircle(graph) {
    var paths = graph.getPaths(info = []), info;
    if (info.length) ChangeSS.error.cyclicInherit(info.map(function (scope) {
      return '[' + (scope.globalName || scope.selector || scope.symbol) + ']';
    }).join('->'), graph);
    return paths;
  }

  function setGlobalNameIFNot(name, sheetName) {
    if (name.indexOf('->') > -1)return name;
    if (!sheetName)Error('sheetName need');
    return name + '->' + sheetName;
  }

  var validateMixCircle, validateExtCircle, linkOtherSheet;
  linkOtherSheet = (function () {
    function filterVar(key, value, proName) {
      var i, gn = key;
      if ((i = key.indexOf('->')) == -1)
        gn += '->' + this.name;
      else {
        ChangeSS.get(key.substr(i + 2))[proName][key.substr(0, i)] = value;
        delete this[proName][key];
      }
      value.globalName = gn;
    }

    function linkInclude(scope, sheetname) {
      if (!scope.sheetName)debugger;
      objForEach(scope.includes, function (key, value) {
        delete this[key];
        this[setGlobalNameIFNot(key, sheetname)] = value;
      }, scope.includes);
      scope.exts = scope.exts.map(function (name) {
        return setGlobalNameIFNot(name, sheetname);
      });
      scope.nested.forEach(function (c) {
        linkInclude(c, sheetname);
      });
    }

    function linkOtherSheet(sheet) {
      var sheetName = sheet.name;
      objForEach(sheet.vars, filterVar, sheet, 'vars');
      objForEach(sheet.mixins, function (key, mixin) {
        filterVar.apply(sheet, [key, mixin, 'mixins']);
        linkInclude(mixin, sheetName);
      });
      sheet.scopes.forEach(function (s) {
        linkInclude(s, sheetName);
      });

    }

    return linkOtherSheet;
  })();
  validateMixCircle = (function () {
    function addMixinExts(scope, mixin) {
      var cs;
      List.arrayAdd(scope.exts, mixin.exts);
      mixin.nested.forEach(function (nestin) {
        cs = new Style(nestin.selectors);
        scope.addStyle(cs);
        cs.resolve = resolveToNull;
        cs.validateSelector(scope.selectors);
        addMixinExts(cs, nestin);
      })
    }

    function resolveToNull() {
      return [];
    }

    function injectIncludeExt(path) {
      for (var i = path.length - 1; i > 0; i--)
        addMixinExts(path[i - 1], path[i]);
    }

    function collectInclude(scope, graph) {
      objForEach(scope.includes, function (includeName) {
        var mixObj = ChangeSS.get(includeName, 'mixin') || ChangeSS.error.notExist(includeName);
        graph.addEdge(scope, mixObj);
      });
      scope.nested.forEach(function (child) {
        collectInclude(child, graph);
      });
      return graph;
    }

    function validateMixCircle(sheets, graph) {
      sheets.forEach(function (sheet) {
        sheet.scopes.forEach(function (s) {
          collectInclude(s, graph);
        });
        objForEach(sheet.mixins, function (key, mixObj) {
          collectInclude(mixObj, graph);
        });
      });
      reportCircle(graph).forEach(injectIncludeExt);
    }

    return validateMixCircle;
  })();
  validateExtCircle = (function () {
    function copyExtToSheet(scope, sheet) {
      var cscope = scope.clone();
      sheet.add({value: cscope, type: 'style'});
      return cscope;
    }

    function handleExtPath(path) {
      for (var i = 0, superScope = path[i], baseScope = path[i + 1]; baseScope; superScope = path[++i], baseScope = path[i + 1]) {
        if (baseScope.sheetName !== superScope.sheetName)
          baseScope = copyExtToSheet(baseScope, ChangeSS.get(superScope.sheetName));
        List.arrayAdd(baseScope.selectors, superScope.selector);
        baseScope._selector = null;
      }
      return path;
    }

    function collectExt(scope, graph) {
      if (!scope.sheetName)Error('no sheetName');
      scope.exts.forEach(function (name) {
        ChangeSS.get(name, 'styles').forEach(function (style) {
          graph.addEdge(scope, style);
        });
      });
      scope.nested.forEach(function (s) {
        collectExt(s, graph);
      });
    }

    function validateExtCircle(sheets, graph) {
      sheets.forEach(function (sheet) {
        sheet.scopes.forEach(function (s) {
          collectExt(s, graph);
        });
      });
      reportCircle(graph).forEach(handleExtPath);
    }

    return validateExtCircle;
  })();
  return function (sheets) {
    var includeGraph, extGraph;
    includeGraph = new Graph();
    extGraph = new Graph();
    sheets.forEach(linkOtherSheet);
    validateMixCircle(sheets, includeGraph);
    validateExtCircle(sheets, extGraph);
    return sheets;
  }
})();/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* ignore*/;
break;
case 1:return 39;
break;
case 2:this.begin("EXP");return 46;
break;
case 3:return 27;
break;
case 4:this.begin("EXP");return 50;
break;
case 5:this.begin('EXT');return 30;
break;
case 6:return 48;
break;
case 7:this.begin("EXP");return 5;
break;
case 8:this.popState();return 31;
break;
case 9:return 4;
break;
case 10:return 31;
break;
case 11:/* ignore*/;
break;
case 12:this.begin("EXP");return 22;
break;
case 13:return 24;
break;
case 14:this.popState();return 34;
break;
case 15:this.popState();return 35;
break;
case 16:return 14;
break;
case 17:return 15;
break;
case 18:return 22;
break;
case 19:return 6;
break;
case 20:return 44;
break;
case 21:return 41;
break;
case 22:return 36;
break;
case 23:return 8;
break;
case 24:popUntil(this,'INITIAL');return 24;
break;
case 25:return "STRING";
break;
case 26:return "URL";
break;
case 27:return 16;
break;
case 28:return 10;
break;
case 29:return 11;
break;
case 30:return 12;
break;
case 31:return 13;
break;
case 32:return 6;
break;
case 33:return 6;
break;
case 34:return 6;
break;
case 35:return "EOF";
break;
}
},
rules: [/^(?:(\/\*[\s\S]*?\*\/|\/\/.*?[\r\n]))/,/^(?:@mixin\b)/,/^(?:@media\b)/,/^(?:@include\b)/,/^(?:@sheetname\b)/,/^(?:@extend\b)/,/^(?:@(-(webkit|moz|ms|o)-)?keyframes\b)/,/^(?:->)/,/^(?:(([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>\+]|\d+%)((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>\+]|\d+%)|[\s>\+\~@\^\$\|\=\[\]\'\"\(\)\r\n\t\f])*?(?=[\;\}\{]))/,/^(?:(\$(([_a-zA-Z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)))/,/^(?:((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>\+]|\d+%)(((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>\+]|\d+%)|[\s>\+\~@\^\$\|\=\[\]\'\"\(\)\r\n\t\f])|(:(:+|\w+-|\b\w+\b(?!\())))*?(?=(\((\$(([_a-zA-Z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)):)|\{|,)))/,/^(?:([\s\r\n\t\f]))/,/^(?::)/,/^(?:;+)/,/^(?:\{)/,/^(?:\})/,/^(?:\()/,/^(?:\))/,/^(?::)/,/^(?:,)/,/^(?:and\b)/,/^(?:,)/,/^(?:&:*((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>\+]|\d+%)(((([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))|[\.#\*\>\+]|\d+%)|[\s>\+\~@\^\$\|\=\[\]\'\"\(\)\r\n\t\f])|(:(:+|\w+-|\b\w+\b(?!\())))*?(?=(\((\$(([_a-zA-Z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)):)|\{|,)))/,/^(?:((\d+(\.\d+)?)|(\.\d+))(%|\w+\b)?)/,/^(?:;+)/,/^(?:@?("|')[\s\S]*?(\1))/,/^(?:(url\(.*?\)|url\((("|')[\s\S]*?(\1))\)))/,/^(?:-?(([_a-z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)(?=\([^$]))/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:#([0-9a-fA-F])+)/,/^(?:(not|only)([\s\r\n\t\f])*(-?(([_a-z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)))/,/^(?:(-?(([_a-z]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))([_a-zA-Z0-9-]|([\200-\377])|((\\{h}{1,6}(\r\n|[ \t\r\n\f])?)|\\[ -~\200-\377]))*)))/,/^(?:$)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16,17,18,21,22,23,34,35],"inclusive":true},"EXP":{"rules":[0,1,2,3,4,5,6,7,9,11,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],"inclusive":true},"EXT":{"rules":[0,1,2,3,4,5,6,7,8,9,11,14,15,16,17,18,21,22,23,34,35],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}